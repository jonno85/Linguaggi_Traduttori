package it.polito.lt.skype.generated.parser;

import draw.*;
import java_cup.runtime.*;
import java.io.InputStreamReader;
import java.util.HashMap;
import java.util.Collection;
import java.util.Iterator;
import java.util.Calendar;
import java.util.ArrayList;
import it.polito.lt.skype.manager.*;
import it.polito.lt.skype.command.*;
import it.polito.lt.skype.parser.*;
import it.polito.lt.skype.bot.*;


init with {:
	vm = new VarManager();
	cp = new CommandParameter[7];
	cpm = new CommandParameter[7][];
	com = null;
	comFind = null;

	array_path = new ArrayList<CommandParameter>();
	array_file = new ArrayList<CommandParameter>();

	array_perm = new ArrayList<CommandParameter>();
	array_data = new ArrayList<CommandParameter>();
	array_dim = new ArrayList<CommandParameter>();

:}

parser code {:

	public VarManager vm;
	public CommandParameter[] cp, datap, permp, dimp ;
	public CommandParameter[][] cpm;
	public ICommand com, comFind;
	public int counter_file = 0;
	public int counter_path = 0;

	public ArrayList<CommandParameter> array_path, array_file, array_dim, array_perm, array_data;
	private String enviroment = "/home";

	public void add_param(CommandParameter x) throws ParserException
	{
		Utility.mf(x.getValue()+" tipo "+x.getParamType());
		if(x.getParamType()==ParamType.PATH)
			array_path.add(x);
		else
			array_file.add(x);
	}

	public void setEnviroment(String path)
	{
		enviroment = path;
		Utility.mf("CURRENT-PATH now is: " + enviroment);
	}

	public String getEnviroment()
	{
		return enviroment;
	}

:};


terminal String Com_Ex, Com_Find, Com_Rm, Com_MKDir, Com_Cp, Com_Cd, Com_If, Com_If_2, Com_If_m, Com_If_e, Com_For, Com_For_e, Com_For_m, Com_Ls, Com_Str, Com_Mov, Com_P;
terminal String Ext, ID, File, Path, Order,Data ,Month, Day, Date_Criteria,Permission_Criteria,Dimension_Criteria, Obj, Where, Prep_supp, Min,Magg,Minug,Maggug,Diver, C_Ug, C_And, C_Or, C_Ugg, C_Andd, C_Orr, C_Not, Var, SO, SC, RO, RC, Minus, Plus, Times,Div, FUnit, IUnit, Minor, Pv, Name, Result, Throw_S, Start_S, End_S, Str, EL;
terminal Integer Int;
terminal Float Vint;
terminal Calendar GMA;
terminal Uminus;
terminal Boolean Bool;


non terminal S;
non terminal stmt,  init_stmt, str_stmt, assig_stmt, i_stmt;
non terminal i_conds, bool_exp, if_head, _where, cond, cond_if, comm_find_stmt, comm_find_stmt_2, i_cc_conds,cc_date_cond, cc_permission_cond, cc_dimension_cond ,cc_conds, script;
non terminal myVar i_arg, arit_stmt, for_arg, arit_arg;
non terminal myVar[] for_head;
non terminal String commands,i_Op, i_Op_ps, start_s, throw_s, bool_op, conf_exp, conf,date_arg;
non terminal String[] for_tail;
non terminal Object[]  sh_stmt, for_stmt, if_stmt,LS_stmt;
//non terminal Calendar date_arg;
non terminal CommandParameter param;

precedence left Minus, Plus, C_Or;
precedence left Div, Times, C_And;
precedence left C_Not;

start with S;

// elemento radice

S 		::= 	/* empty */
		| i_stmt
;

// ********************* script

script		::= start_s i_stmt End_S
;

// ********************* comandi di gestione script

start_s		::= Start_S File
;

throw_s		::= Throw_S File
;

// ********************* insieme di statement

i_stmt		::= stmt		{://RE-Init
					parser.cp = new CommandParameter[7];
					parser.cpm = new CommandParameter[7][];
					parser.com = null;
					parser.comFind = null;
					:}
		| i_stmt stmt
;

// ********************* statemente generali

stmt 		::= init_stmt EL	{: parser.vm.getListVar(); 	:}	
		| assig_stmt:x EL	{: parser.vm.assig(((myVar)x)); :}
		| str_stmt EL
		| sh_stmt:x EL		{:
					System.out.println("raccolto sh stmt: parameter setting"); 
					/*parser.cp[0] = parser.array_file.get(0);
					parser.cp[1] = parser.array_path.get(0);
					parser.cp[2] = parser.array_perm.get(0);
					parser.cp[3] = parser.array_data.get(0);
					parser.cp[4] = parser.array_dim.get(0);*/
					for(int i=0; i<7; i++)
						if(parser.cp[i]==null)
							Utility.mf("*niente*");
						else
							Utility.mf("param["+i+"]: "+parser.cp[i].getValue());
					parser.com.setCommandParameter(parser.cp);
					parser.com.exec();
					Utility.mf(parser.com.getCommandStringResult());
					
					:}
		| comm_find_stmt EL	{:
					System.out.println("raccolto sh stmt = FIND");
					parser.cpm[0] = new CommandParameter[parser.array_file.size()];
					parser.cpm[1] = new CommandParameter[parser.array_path.size()];
					parser.cpm[2] = new CommandParameter[parser.array_perm.size()];
					parser.cpm[3] = new CommandParameter[parser.array_data.size()];
					parser.cpm[4] = new CommandParameter[parser.array_dim.size()];

					System.out.println("dopo onit");
					parser.cpm[0] = parser.array_file.toArray(parser.cpm[0]);
					parser.cpm[1] = parser.array_path.toArray(parser.cpm[1]);
					parser.cpm[2] = parser.array_perm.toArray(parser.cpm[2]);
					parser.cpm[3] = parser.array_data.toArray(parser.cpm[3]);
					parser.cpm[4] = parser.array_dim.toArray(parser.cpm[4]);

					//parser.cpm[6]=new CommandParameter[7];

					System.out.println("dopo init 2'");
					for(int i=0; i<7; i++)
						if(parser.cp[i]==null)
							Utility.mf("cp niente:"+i);
						else
							Utility.mf("cp param["+i+"]: "+parser.cp[i].getValue());

					parser.cpm[6] = parser.cp;

					for(int i=0;i<7;i++){
						if(parser.cp[i]==null)
							Utility.mf("cpm niente:"+i);
						else
							Utility.mf("cpm param[6]["+i+"]: "+parser.cpm[6][i].getValue());
					}
/*
					for(int i=0; i<7; i++){
						if(parser.cpm[i]==null)
							continue;
						int len = parser.cpm[i].length;
						for(int j=0;j<len;j++){
							if(parser.cpm[i][j]==null)
								Utility.mf("param["+i+"]["+j+"]: niente");
							else
								Utility.mf("param["+i+"]["+j+"]: "+parser.cpm[i][j].getValue());
						}
					}*/
					Utility.mf("SETCOMMANDPARAMETER");
					parser.comFind.setCommandParameter(parser.cpm);
					Utility.mf("EXEC");
					parser.comFind.exec();
					parser.array_file.clear();
					parser.array_path.clear();
					parser.array_perm.clear();
					parser.array_data.clear();
					parser.array_dim.clear();
					
					Utility.mf(parser.comFind.getCommandStringResult());
					:}
		| start_s EL
		| throw_s EL
		| Com_P arit_stmt EL
		| conf_exp EL /*********************************************/
		| EL
;

// ********************* statement controllo di flusso

str_stmt	::= if_stmt
		| for_stmt
		| str_stmt for_stmt
		| str_stmt if_stmt
;

// ********************* statement di assegnazione valori

assig_stmt	::= Var:x C_Ug arit_stmt:y	{: ((myVar)y).setName(x); RESULT = y; 	:}
		| Var:x				{: RESULT = new myVar(x); 		:}
;

// ********************* statement di inizializzazione variabili

init_stmt	::= Com_Str assig_stmt:x	{: parser.vm.add_var(((myVar)x)); 	:}	
		| init_stmt assig_stmt:x	{: parser.vm.add_var(((myVar)x)); 	:}
;

// ********************* gestione operazioni algebriche - booleane - concatenazione

arit_stmt	::= arit_stmt:x Times:s arit_stmt:y	
		{:	System.out.println(s);
			((myVar)x).printVar(); 
			System.out.println("segno operazione: "+s); y.printVar(); 
			RESULT = parser.vm.makeOper(((myVar)x),((myVar)y),s); 		:}
		| arit_stmt:x Div:s arit_stmt:y	
		{:	System.out.println(s);
			((myVar)x).printVar(); 
			System.out.println("segno operazione: "+s); y.printVar(); 
			RESULT = parser.vm.makeOper(((myVar)x),((myVar)y),s); 		:}
		| arit_stmt:x Plus:s arit_stmt:y	
		{:	System.out.println(s);
			((myVar)x).printVar(); 
			System.out.println("segno operazione: "+s); y.printVar(); 
			RESULT = parser.vm.makeOper(((myVar)x),((myVar)y),s); 		:}
		| arit_stmt:x Minus:s arit_stmt:y	
		{:	System.out.println(s);
			((myVar)x).printVar(); 
			System.out.println("segno operazione: "+s); y.printVar(); 
			RESULT = parser.vm.makeOper(((myVar)x),((myVar)y),s); 		:}
		| arit_stmt:x C_And:s arit_stmt:y	
		{:	System.out.println(s);
			((myVar)x).printVar(); 
			System.out.println("segno operazione: "+s); y.printVar(); 
			RESULT = parser.vm.makeOper(((myVar)x),((myVar)y),s); 		:}
		| arit_stmt:x C_Or:s arit_stmt:y	
		{:	System.out.println(s);
			((myVar)x).printVar(); 
			System.out.println("segno operazione: "+s); y.printVar(); 
			RESULT = parser.vm.makeOper(((myVar)x),((myVar)y),s); 		:}
		| Minus:s arit_stmt:x		{: RESULT = parser.vm.makeSOper(((myVar)x),s); :}%prec Minus
		| arit_arg:x			{: RESULT = ((myVar)x); 		:}
		| RO arit_stmt:x RC 		{: RESULT = ((myVar)x); 		:}
		| C_Not:s arit_stmt:x		{: RESULT = parser.vm.makeSOper(((myVar)x),s); :}
;

// ***************** argomenti che subiscono un'operazione 
// ***************** algebrica - booleana - concatenazione

arit_arg	::= Var:x			{: RESULT = parser.vm.extractVar(x); 
							System.out.println("Var: "+x); :}
		| i_arg:x			{: RESULT = ((myVar)x); System.out.println("i_arg"); :}
;
 /*
i_Op		::= bool_op:x	{: RESULT = x; :}
		| C_Not:x	{: RESULT = x; :}
;
*/

// ***************** parametri per i comandi

param		::= Path:x	{: RESULT = new CommandParameter(ParamType.PATH,x,null); :}
		| File:x	{: RESULT = new CommandParameter(ParamType.FILE,x,null); :}
		| Ext:x		{: RESULT = new CommandParameter(ParamType.FILE,x,null); :}
;

// ***************** statement relativi ai comandi

sh_stmt		::= commands:c param:p  {: parser.cp[2]=p; :}
		| commands i_cc_conds
		| sh_stmt param:p 	{: parser.cp[3]=p; :}
		| sh_stmt i_cc_conds
		//| commands_oa:x		{: RESULT = x; :}
;

// ***************** comandi con argomenti opzionali 
/*commands_oa	::= Com_Cd
		| Com_Cd Minor
		| Com_Ls		{: 
						Utility.mf("LS!");
						RESULT = new Object[2];
						RESULT[0] = new LSCommand(parser.getEnviroment());
						RESULT[1] = new CommandParameter[5];			
					:}
		| Com_Ls Order:o		{: 
						Utility.mf("LS Order!");
						RESULT = new Object[2];
						RESULT[0] = new LSCommand(parser.getEnviroment());
						CommandParameter[] cp = new CommandParameter[5];
						cp[0]=new CommandParameter(null,o,null);						
						RESULT[1] = cp;
									
					:}
;*/

// ***************** comandi standard mv, rm, cp e aggiunti cd, ls
commands	::= Com_Cd		{: 
					Utility.mf("CD!");
					RESULT= "cd";
					parser.com = new CDCommand(parser.getEnviroment(),parser);
					:}
		//| Com_Cd Minor
		| Com_MKDir		{: 
					Utility.mf("MKDIR!");
					RESULT= "mkdir";
					parser.com = new MKDCommand(parser.getEnviroment());
					:}

		|Com_Mov		{: 
					Utility.mf("MV!");
					RESULT= "mv";
					parser.com = new MVCommand(parser.getEnviroment());
					:}

		| Com_Rm		{: 
					Utility.mf("RM!");
					RESULT= "rm";
					parser.com = new RMCommand(parser.getEnviroment());
					:}

		| Com_Cp		{: 
					Utility.mf("CP!");
					RESULT= "cp";
					parser.com = new CPCommand(parser.getEnviroment());
					:}
		| LS_stmt		{:RESULT= "ls";:}
;

LS_stmt		::= Com_Ls		{: 
					Utility.mf("LS!");
					parser.com = new LSCommand(parser.getEnviroment());
					:}

		| LS_stmt Order:o	{: 
					Utility.mf("LS Order!");
					parser.cp[0]=new CommandParameter(ParamType.BINARIO,o,null);
					:}
		
		| LS_stmt Obj:o		{: 
					Utility.mf("LS obj!");
					parser.cp[1]=new CommandParameter(ParamType.BINARIO,o,null);
					:}
;

// ***************** comando Find		DISTINGUERE tra parametri in pos 0 (estensioni) e 1 (percorsi)
comm_find_stmt	::= Com_Find param:x	{: 
					Utility.mf("_FIND_!");
					parser.comFind = new FINDCommand(parser.getEnviroment());
/*
					parser.counter_file = 0; //posso usare una arraylist e poi convertire in array
					parser.counter_path = 0;*/

					parser.add_param(x);
					:}
		| Com_Find i_cc_conds
		
		| comm_find_stmt param:x
					{:
					Utility.mf("passo dentro comm_find_stmt");
					parser.add_param(x);
					:}
		| comm_find_stmt i_cc_conds
		| comm_find_stmt Com_Ex comm_find_stmt_2 Pv
;

comm_find_stmt_2
		::= commands:sc		{:
					Utility.mf("COMANDO RICORSIVO! rilevato: "+sc);
					parser.cpm[5] = new CommandParameter[]{new CommandParameter(null,sc,null)};
					:}
		| comm_find_stmt_2 Name param:p  
					{:
					Utility.mf("COMANDO RECURSIVO! rilevato:  CON PARAM"); 
					parser.cp[3]=p; 
					:}	//il parametro 2(path src) è già passato dal comando find, in questa condizione è logico solo il param dst
		| comm_find_stmt_2 Name {:
					Utility.mf("COMANDO RECURSIVO! rilevato: SENZA PARAM!"); 
					:}
;
// ***************** condizioni per i comandi
_where		::= 
		| Where
;

i_cc_conds	::= cc_conds
		| i_cc_conds bool_op cc_conds
;
		

cc_conds	::=  cc_permission_cond:x
					{:
					parser.array_perm.add(parser.cp[5]);
//					parser.cp[5] = null;
					:}
		| cc_date_cond:x	{:
					parser.array_data.add(parser.cp[4]);
					:}
		| cc_dimension_cond:x	{:
					parser.array_dim.add(parser.cp[6]);
					:}

;

//dimensione, utilizzati solo in find
cc_dimension_cond ::=
		  _where Dimension_Criteria Min i_arg:a 	{: 
								Utility.mf("Dimension Criteria raccolto valore i_arg ricevuto: "+a.getStringValue());
								parser.cp[6]=new CommandParameter(ParamType.DIMENSIONE,a.getStringValue(),SignType.MIN);		
								:}
		| _where Dimension_Criteria Magg i_arg:a	{: 
								Utility.mf("Dimension Criteria raccolto");
								parser.cp[6]=new CommandParameter(ParamType.DIMENSIONE,a.getStringValue(),SignType.MAG);		
								:}
		| _where Dimension_Criteria Minug i_arg:a	{: 
								Utility.mf("Dimension Criteria raccolto");
								parser.cp[6]=new CommandParameter(ParamType.DIMENSIONE,a.getStringValue(),SignType.MINUG);		
								:}
		| _where Dimension_Criteria Maggug i_arg:a	{: 
								Utility.mf("Dimension Criteria raccolto");
								parser.cp[6]=new CommandParameter(ParamType.DIMENSIONE,a.getStringValue(),SignType.MAGUG);		
								:}
		| _where Dimension_Criteria Diver i_arg:a{: 
								Utility.mf("Dimension Criteria raccolto");
								parser.cp[6]=new CommandParameter(ParamType.DIMENSIONE,a.getStringValue(),SignType.DIV);		
								:}
		| _where Dimension_Criteria C_Ug i_arg:a	{: 
								Utility.mf("Dimension Criteria raccolto OK");
								parser.cp[6]=new CommandParameter(ParamType.DIMENSIONE,a.getStringValue(),SignType.UG);		
								:}
;

//permessi
cc_permission_cond ::=
		 _where Permission_Criteria Min i_arg:a 	{: 
								Utility.mf("Dimension Criteria raccolto");
								parser.cp[5]=new CommandParameter(ParamType.PERMESSI,a.getStringValue(),SignType.MIN);
								:}

		| _where Permission_Criteria Magg i_arg:a	{: 
								Utility.mf("Dimension Criteria raccolto");
								parser.cp[5]=new CommandParameter(ParamType.PERMESSI,a.getStringValue(),SignType.MAG);		
								:}

		| _where Permission_Criteria Minug i_arg:a	{: 
								Utility.mf("Dimension Criteria raccolto");
								parser.cp[5]=new CommandParameter(ParamType.PERMESSI,a.getStringValue(),SignType.MINUG);		
								:}

		| _where Permission_Criteria Maggug i_arg:a	{: 
								Utility.mf("Dimension Criteria raccolto");
								parser.cp[5]=new CommandParameter(ParamType.PERMESSI,a.getStringValue(),SignType.MAGUG);		
								:}

		| _where Permission_Criteria Diver i_arg:a	{: 
								Utility.mf("Dimension Criteria raccolto");
								parser.cp[5]=new CommandParameter(ParamType.PERMESSI,a.getStringValue(),SignType.DIV);
								:}

		| _where Permission_Criteria C_Ug i_arg:a	{: 
								Utility.mf("Dimension Criteria raccolto permesso = : OK");
								parser.cp[5]=new CommandParameter(ParamType.PERMESSI,a.getStringValue(),SignType.UG);			
								:}
;		
//date
cc_date_cond ::=
		 _where Date_Criteria Min date_arg:a	{: 
								Utility.mf("Date Criteria MIN raccolto");
								parser.cp[4]=new CommandParameter(ParamType.DATA,a,SignType.MIN);					
							:}
		| _where Date_Criteria Magg date_arg:a	{: 
								Utility.mf("Date Criteria MAG raccolto");
								parser.cp[4]=new CommandParameter(ParamType.DATA,a,SignType.MAG);					
								:}
		| _where Date_Criteria Minug date_arg:a		{: 
								Utility.mf("Date Criteria MINUG raccolto");
								parser.cp[4]=new CommandParameter(ParamType.DATA,a,SignType.MINUG);					
								:}
		| _where Date_Criteria Maggug date_arg:a	{: 
								Utility.mf("Date Criteria MAGUG raccolto");
								parser.cp[4]=new CommandParameter(ParamType.DATA,a,SignType.MAGUG);					
								:}
		| _where Date_Criteria Diver date_arg:a		{: 
								Utility.mf("Date Criteria DIV raccolto");
								parser.cp[4]=new CommandParameter(ParamType.DATA,a,SignType.DIV);					
								:}
		| _where Date_Criteria C_Ug date_arg:a		{: 
								Utility.mf("Date Criteria UG raccolto");
								parser.cp[4]=new CommandParameter(ParamType.DATA,a,SignType.UG);					
								:}
;


bool_op		::= C_And:x 	{: RESULT =x; :}
		| C_Or:x 	{: RESULT =x; :}
;

// ***************** argomento data
date_arg	::= Data:x	{: RESULT = x;			:};
// ***************** argomento generico

	//GMA:x	{: RESULT = new myVar(myVar._string, x);			:}
i_arg		::= Int:x		{: RESULT = new myVar(myVar._int, x.intValue()); 		:}
		| Vint:x	{: RESULT= new myVar(myVar._float, x.floatValue()); 		:}
		| Str:x		{: System.out.println("str: "+x); 
					RESULT= new myVar(myVar._string, x); 			:}
		| IUnit:x	{: RESULT= new myVar(myVar._string, x); 			:}//verificare la dimensione
		| FUnit:x	{: RESULT= new myVar(myVar._string, x); 			:}
		| Bool:x	{: RESULT= new myVar(myVar._bool, new Boolean(x)); 		:}
;


// ***************** espressione booleana

cond_if		::= C_Orr
		| C_Andd
;

conf		::= arit_stmt cond arit_stmt
/*		| arit_stmt cond_if arit_stmt*/
;

conf_exp	::= conf
		| C_Not conf
/*		| conf cond_if conf*/
		| conf_exp cond_if conf
		| conf_exp cond_if arit_stmt
;

/*
not_exp		::= C_Not Var 
		| C_Not i_arg
;
*/

// **************** IF statement

if_head		::= Com_If conf_exp Com_If_2 EL i_stmt
;

if_stmt		::= if_head Com_If_m EL i_stmt Com_If_e
		| if_head Com_If_e
;

// **************** FOREACH statement

for_arg		::= Var:x	{: RESULT = new myVar(x); 				:}
		| Int:x		{: RESULT = new myVar(myVar._int, x.intValue()); 	:}
		| Vint:x	{: RESULT= new myVar(myVar._float, x.floatValue()); 	:}
		| ID:x		{: RESULT= new myVar(myVar._string, x); :}
;

for_head	::= Com_For for_arg:x for_arg:y for_arg:z Com_For_m EL
		{: System.out.println("for_head variabili \n"+x.toString()+"\n"+y.toString()+"\n"+z.toString());
		// passiamo un vettore contenente le tre variabili sulle quali controllare il ciclo for
			RESULT= new myVar[3];
			RESULT[0]= x;
			RESULT[1]= y;
			RESULT[2]= z;							:}	
;

i_Op_ps		::= Plus:x	{: RESULT = x; 						:}
		| Minus:x	{: RESULT = x; 						:}
;

for_tail 	::= Com_For_e i_Op_ps:x for_arg:y 
		{: 	//passiamo un vettore di 2 elementi stringe contenenti l'operatore e il fattore
			System.out.println("dentro for tail");
			RESULT= new String[2];
			RESULT[0]= (String)x.toString();
			RESULT[1]= ((myVar)y).getName();
			System.out.println(" valore: "+y.toString());
			System.out.println("operatore: "+x.toString()); 		:}
;

for_stmt	::= for_head:x i_stmt for_tail:y
		{:	System.out.println("for cycle");
			RESULT= new Object[5];
			RESULT[0] = (myVar)x[0];
			RESULT[1] = (myVar)x[1];
			RESULT[2] = (myVar)x[2];			
			RESULT[3] = parser.vm.extractVar(y[1].toString());  
			RESULT[4] = (String)y[0];					:}
;


