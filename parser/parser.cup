package it.polito.lt.skype.generated.parser;


import java_cup.runtime.*;
import java.io.InputStreamReader;
import java.util.HashMap;
import java.util.Collection;
import java.util.Iterator;
import java.util.Calendar;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Iterator;
import it.polito.lt.skype.manager.*;
import it.polito.lt.skype.command.*;
import it.polito.lt.skype.parser.*;
import it.polito.lt.skype.bot.*;


init with {:
	vm = new VarManager();
	cp = new CommandParameter[7];
	cpm = new CommandParameter[7][];
	com = null;
	comFind = null;

	array_path = new ArrayList<CommandParameter>();
	array_file = new ArrayList<CommandParameter>();
	array_perm = new ArrayList<CommandParameter>();
	array_data = new ArrayList<CommandParameter>();
	array_dim = new ArrayList<CommandParameter>();

	ifcc = null;
	ic = null;

	list_script = new LinkedList<ICommand>();
	todo = new LinkedList<ICommand>();

:}

parser code {:

	public VarManager vm;
	public CommandParameter[] cp, datap, permp, dimp ;
	public CommandParameter[][] cpm;
	public ICommand com, comFind;
	public int counter_file = 0;
	public int counter_path = 0;
	public int sublevel = 0;

	public ArrayList<CommandParameter> array_path, array_file, array_dim, array_perm, array_data;

	public LinkedList<ICommand> list_script;
	public LinkedList<ICommand> todo;
	public IFlowCommandControl ifcc;
	public ICommand ic;
	public boolean if_control = false;

	private String enviroment = "/home";

	public void add_param(CommandParameter x) throws ParserException
	{
		Utility.mf(x.getValue()+" tipo "+x.getParamType());
		if(x.getParamType()==ParamType.PATH)
			array_path.add(x);
		else
			array_file.add(x);
	}

	public void setEnviroment(String path)
	{
		enviroment = path;
		Utility.mf("CURRENT-PATH now is: " + enviroment);
	}

	public String getEnviroment()
	{
		return enviroment;
	}

	public void print_el(LinkedList ls)
	{
		LinkedList ll = ls;
		Utility.mf("ITERATORE ");
		Iterator s = ll.iterator();
		while(s.hasNext())
			((IFlowCommandControl)s.next()).print_parameters();
	}
:}
;


<<<<<<< HEAD
<<<<<<< HEAD
terminal Com_Ex, Com_Find, Com_Rm, Com_MKDir, Com_Cp, Com_Cd, Com_If, Com_If_2, Com_If_m, Com_If_e, Com_For, Com_For_e, Com_For_m, Com_Ls, Com_Str, Com_Mov, Com_P, Script_Var;
terminal Ext, ID, File, Path, Order,Data ,Month, Day, Date_Criteria,Permission_Criteria,Dimension_Criteria, Obj, Where, Prep_supp, Min,Magg,Minug,Maggug,Diver, C_Ug, C_And, C_Or, C_Ugg, C_Andd, C_Orr, C_Not, Var, SO, SC, RO, RC, Minus, Plus, Times,Div, FUnit, IUnit, Minor, Pv, Name, Result, Throw_S, Start_S, End_S, Str, FileScript, EL;
terminal Int;
terminal Vint;
terminal GMA;
terminal Uminus;
terminal Bool;


non terminal S;
non terminal assig_stmt;
non terminal i_conds, bool_exp, _where, cond, comm_find_stmt, comm_find_stmt_2, i_cc_conds,cc_date_cond, cc_permission_cond, cc_dimension_cond ,cc_conds, script;
non terminal i_arg, arit_stmt, for_arg, arit_arg, conf_exp, logic_stmt, for_tail;
//non terminal myVar[] 
non terminal commands,i_Op, i_Op_ps, start_s, throw_s, end_s, bool_op, conf,date_arg, cond_if;
non terminal sh_stmt, LS_stmt;
//non terminal Calendar date_arg;
non terminal param;
non terminal for_stmt, for_head;
non terminal if_stmt, if_head;
non terminal i_stmt;
non terminal init_stmt, stmt, str_stmt;
=======
terminal String		Com_Ex, Com_Find, Com_Rm, Com_MKDir, Com_Cp, Com_Cd, Com_If, Com_If_2, Com_If_m, Com_If_e, Com_For, Com_For_e, Com_For_m, Com_Ls, Com_Str, Com_Mov, Com_P, Script_Var;
terminal String		Ext, ID, File, Path, Order,Data ,Month, Day, Date_Criteria,Permission_Criteria,Dimension_Criteria, Obj, Where, Prep_supp, Min,Magg,Minug,Maggug,Diver, C_Ug, C_And, C_Or, C_Ugg, C_Andd, C_Orr, C_Not, Var, SO, SC, RO, RC, Minus, Plus, Times,Div, FUnit, IUnit, Minor, Pv, Name, Result, Throw_S, Start_S, End_S, Str, FileScript, EL;
terminal Integer	Int;
terminal Float		Vint;
terminal Calendar	GMA;
terminal 		Uminus;
terminal Boolean	Bool;


non terminal		S;
non terminal		assig_stmt;
non terminal		i_conds, bool_exp, _where, cond, comm_find_stmt, comm_find_stmt_2, i_cc_conds,cc_date_cond, cc_permission_cond, cc_dimension_cond ,cc_conds, script;
non terminal myVar	i_arg, arit_stmt, for_arg, arit_arg, conf_exp, logic_stmt, for_tail;
//non terminal myVar[] 
=======
terminal String		Com_Ex, Com_Find, Com_Rm, Com_MKDir, Com_Cp, Com_Cd, Com_If, Com_If_2, Com_If_m, Com_If_e, Com_For, Com_For_e, Com_For_m, Com_Ls, Com_Str, Com_Mov, Com_P, Script_Var;
terminal String		Ext, ID, File, Path, Order,Data ,Month, Day, Date_Criteria,Permission_Criteria,Dimension_Criteria, Obj, Where, Prep_supp, Min,Magg,Minug,Maggug,Diver, C_Ug, C_And, C_Or, C_Ugg, C_Andd, C_Orr, C_Not, Var, SO, SC, RO, RC, Minus, Plus, Times,Div, FUnit, IUnit, Minor, Pv, Name, Result, Throw_S, Start_S, End_S, Str, FileScript, EL;
terminal Integer	Int;
terminal Float		Vint;
terminal Calendar	GMA;
terminal 		Uminus;
terminal Boolean	Bool;


non terminal		S;
non terminal		assig_stmt;
non terminal		i_conds, bool_exp, _where, cond, comm_find_stmt, comm_find_stmt_2, i_cc_conds,cc_date_cond, cc_permission_cond, cc_dimension_cond ,cc_conds, script;
non terminal myVar	i_arg, arit_stmt, for_arg, arit_arg, conf_exp, logic_stmt, for_tail;
//non terminal myVar[] 
>>>>>>> 5d92e7635efda2bb40eb59fe2db1a09fc93d44ee
non terminal String		commands,i_Op, i_Op_ps, start_s, throw_s, end_s, bool_op, conf,date_arg, cond_if;
non terminal Object[]		sh_stmt, LS_stmt;
//non terminal Calendar		date_arg;
non terminal CommandParameter	param;
non terminal for_command	for_stmt, for_head;
non terminal if_command		if_stmt, if_head;
non terminal LinkedList		i_stmt;
non terminal ICommand		init_stmt, stmt, str_stmt;
<<<<<<< HEAD
>>>>>>> 5d92e7635efda2bb40eb59fe2db1a09fc93d44ee
=======
>>>>>>> 5d92e7635efda2bb40eb59fe2db1a09fc93d44ee


precedence left Minus, Plus, C_Or;
precedence left Div, Times, C_And;
precedence left C_Not;

start with S;

// elemento radice

S 		::= 	/* empty */
		| i_stmt
;

// ********************* script

script		::= start_s i_stmt:x end_s
					{:
					Utility.mf("CHIUDO SCRIPT");
					//salvataggio script
					:}
;

// ********************* comandi di gestione script

start_s			::= Start_S File:s EL
					{:
					Utility.mf("INIZIO SCRIPT");
					parser.list_script = new LinkedList<ICommand>();
					//parser.list_script.add(s);
					:}
;

throw_s		::= Throw_S File
;

end_s		::= End_S File:s
					{:
					Utility.mf("FINE SCRIPT");
					:}
;

// ********************* insieme di statement

i_stmt		::= stmt:s		{://RE-Init
					parser.todo.add(s);
					parser.cp = new CommandParameter[7];
					parser.cpm = new CommandParameter[7][];
					parser.com = null;
					parser.comFind = null;
					:}
		| i_stmt stmt:s
;

// ********************* statemente generali

stmt 		::= init_stmt EL	{: parser.vm.getListVar(); Utility.mf("INIT STMT");	:}
		| assig_stmt:x EL	{: parser.vm.assig(((myVar)x)); Utility.mf("ASSIST STMT");:}
		| str_stmt:s EL		{:
					parser.list_script.add(s);
					Utility.mf("risolto flow control statement -> INSERITO IN LIST SCRIPT"); 
					:}
		| sh_stmt:x EL		{:
					System.out.println("raccolto sh stmt: parameter setting"); 
					parser.cp[0] = parser.array_file.get(0);
					parser.cp[1] = parser.array_path.get(0);
					parser.cp[2] = parser.array_perm.get(0);
					parser.cp[3] = parser.array_data.get(0);
					parser.cp[4] = parser.array_dim.get(0);
					for(int i=0; i<7; i++)
						if(parser.cp[i]==null)
							Utility.mf("*niente*");
						else
							Utility.mf("param["+i+"]: "+parser.cp[i].getValue());
					parser.com.setCommandParameter(parser.cp);
					parser.com.exec();
					Utility.mf(parser.com.getCommandStringResult());
					
					:}
		| comm_find_stmt EL	{:
					System.out.println("raccolto sh stmt = FIND");
					parser.cpm[0] = new CommandParameter[parser.array_file.size()];
					parser.cpm[1] = new CommandParameter[parser.array_path.size()];
					parser.cpm[2] = new CommandParameter[parser.array_perm.size()];
					parser.cpm[3] = new CommandParameter[parser.array_data.size()];
					parser.cpm[4] = new CommandParameter[parser.array_dim.size()];

					System.out.println("dopo onit");
					parser.cpm[0] = parser.array_file.toArray(parser.cpm[0]);
					parser.cpm[1] = parser.array_path.toArray(parser.cpm[1]);
					parser.cpm[2] = parser.array_perm.toArray(parser.cpm[2]);
					parser.cpm[3] = parser.array_data.toArray(parser.cpm[3]);
					parser.cpm[4] = parser.array_dim.toArray(parser.cpm[4]);

					//parser.cpm[6]=new CommandParameter[7];

					System.out.println("dopo init 2'");

					Utility.mf("SETCOMMANDPARAMETER");
					parser.comFind.setCommandParameter(parser.cpm);
					Utility.mf("EXEC");
					parser.comFind.exec();
					parser.array_file.clear();
					parser.array_path.clear();
					parser.array_perm.clear();
					parser.array_data.clear();
					parser.array_dim.clear();
					
					Utility.mf(parser.comFind.getCommandStringResult());
					:}
		| script EL
		| throw_s EL
		| Com_P arit_stmt EL
		| conf_exp EL /*********************************************/
		| EL
;

// ********************* statement controllo di flusso

str_stmt	::= if_stmt:x			{: 
						((if_command)x).print_parameters();
						Utility.mf("raccolto IF stmt"); :}
		| for_stmt:x			{: 
						//x.print_parameters(); nullpointerexc
						Utility.mf("raccolto FOR stmt"); :}
		| str_stmt for_stmt		{: Utility.mf("raccolto FOR stmt interno"); :}
		| str_stmt if_stmt		{: Utility.mf("raccolto IF stmt interno"); :}
;

// ********************* statement di assegnazione valori

assig_stmt	::= Var:x C_Ug arit_stmt:y	{: ((myVar)y).setName(x);
						RESULT = y; 	:}
		| Var:x				{: RESULT = new myVar(x); 		:}
;

// ********************* statement di inizializzazione variabili

init_stmt	::= Com_Str assig_stmt:x	{: parser.vm.add_var(((myVar)x)); 	:}	
		| init_stmt assig_stmt:x	{: parser.vm.add_var(((myVar)x)); 	:}
;

// ********************* gestione operazioni algebriche - booleane - concatenazione

arit_stmt	::= arit_stmt:x Times:s arit_stmt:y	
		{:	System.out.println(s);
			((myVar)x).printVar(); 
			System.out.println("segno operazione: "+s); y.printVar(); 
			RESULT = parser.vm.makeOper(((myVar)x),((myVar)y),s); 		:}
		| arit_stmt:x Div:s arit_stmt:y	
		{:	System.out.println(s);
			((myVar)x).printVar(); 
			System.out.println("segno operazione: "+s); y.printVar(); 
			RESULT = parser.vm.makeOper(((myVar)x),((myVar)y),s); 		:}
		| arit_stmt:x Plus:s arit_stmt:y	
		{:	System.out.println(s);
			((myVar)x).printVar(); 
			System.out.println("segno operazione: "+s); y.printVar(); 
			RESULT = parser.vm.makeOper(((myVar)x),((myVar)y),s); 		:}
		| arit_stmt:x Minus:s arit_stmt:y	
		{:	System.out.println(s);
			((myVar)x).printVar(); 
			System.out.println("segno operazione: "+s); y.printVar(); 
			RESULT = parser.vm.makeOper(((myVar)x),((myVar)y),s); 		:}
		| arit_stmt:x C_And:s arit_stmt:y	
		{:	System.out.println(s);
			((myVar)x).printVar(); 
			System.out.println("segno operazione: "+s); y.printVar(); 
			RESULT = parser.vm.makeOper(((myVar)x),((myVar)y),s); 		:}
		| arit_stmt:x C_Or:s arit_stmt:y	
		{:	System.out.println(s);
			((myVar)x).printVar(); 
			System.out.println("segno operazione: "+s); y.printVar(); 
			RESULT = parser.vm.makeOper(((myVar)x),((myVar)y),s); 		:}
		| Minus:s arit_stmt:x		{: RESULT = parser.vm.makeSOper(((myVar)x),s); :}%prec Minus
		| arit_arg:x			{: RESULT = ((myVar)x); 		:}
		| RO arit_stmt:x RC 		{: RESULT = ((myVar)x); 		:}
		| C_Not:s arit_stmt:x		{: RESULT = parser.vm.makeSOper(((myVar)x),s); :}
;

//check the possibility to extract each time the real value


logic_stmt	::= arit_stmt:x Magg arit_stmt:y
		{:
			RESULT = new myVar(myVar._bool,parser.vm.makeLOMag(x,y));
		:}
		| arit_stmt:x Maggug arit_stmt:y
		{:
			RESULT = new myVar(myVar._bool,parser.vm.makeLOMaU(x,y));
		:}
		| arit_stmt:x Min arit_stmt:y
		{:
			RESULT = new myVar(myVar._bool,parser.vm.makeLOMin(x,y));
		:}
		| arit_stmt:x Minug arit_stmt:y
		{:
			RESULT = new myVar(myVar._bool,parser.vm.makeLOMiU(x,y));
		:}
		| arit_stmt:x C_Ugg arit_stmt:y
		{:
			RESULT = new myVar(myVar._bool,parser.vm.makeLOUg(x,y));
		:}
		| arit_stmt:x Diver arit_stmt:y
		{:
			RESULT = new myVar(myVar._bool,parser.vm.makeLODiv(x,y));
		:}
;

// ***************** argomenti che subiscono un'operazione 
// ***************** algebrica - booleana - concatenazione

arit_arg	::= Var:x			{: RESULT = parser.vm.extractVar(x); 
							System.out.println("Var: "+x); :}
		| i_arg:x			{: RESULT = ((myVar)x); System.out.println("i_arg"); :}
;

//i_Op		::= bool_op:x	{: RESULT = x; :}
//		| C_Not:x	{: RESULT = x; :}
//;


// ***************** parametri per i comandi

param		::= Path:x	{: RESULT = new CommandParameter(ParamType.PATH,x,null); :}
		| File:x	{: RESULT = new CommandParameter(ParamType.FILE,x,null); :}
		| Ext:x		{: RESULT = new CommandParameter(ParamType.FILE,x,null); :}
;

// ***************** statement relativi ai comandi

sh_stmt		::= commands:c param:p  {: parser.cp[2]=p; :}
		| commands i_cc_conds
		| sh_stmt param:p 	{: parser.cp[3]=p; :}
		| sh_stmt i_cc_conds
		//| commands_oa:x		{: RESULT = x; :}
;

// ***************** comandi standard mv, rm, cp e aggiunti cd, ls
commands	::= Com_Cd		{: 
					Utility.mf("CD!");
					RESULT= "cd";
					parser.com = new CDCommand(parser.getEnviroment(),parser);
					:}
		//| Com_Cd Minor
		| Com_MKDir		{: 
					Utility.mf("MKDIR!");
					RESULT= "mkdir";
					parser.com = new MKDCommand(parser.getEnviroment());
					:}

		|Com_Mov		{: 
					Utility.mf("MV!");
					RESULT= "mv";
					parser.com = new MVCommand(parser.getEnviroment());
					:}

		| Com_Rm		{: 
					Utility.mf("RM!");
					RESULT= "rm";
					parser.com = new RMCommand(parser.getEnviroment());
					:}

		| Com_Cp		{: 
					Utility.mf("CP!");
					RESULT= "cp";
					parser.com = new CPCommand(parser.getEnviroment());
					:}
		| LS_stmt		{:RESULT= "ls";:}
;

LS_stmt		::= Com_Ls		{: 
					Utility.mf("LS!");
					parser.com = new LSCommand(parser.getEnviroment());
					:}

		| LS_stmt Order:o	{: 
					Utility.mf("LS Order!");
					parser.cp[0]=new CommandParameter(ParamType.BINARIO,o,null);
					:}
		
		| LS_stmt Obj:o		{: 
					Utility.mf("LS obj!");
					parser.cp[1]=new CommandParameter(ParamType.BINARIO,o,null);
					:}
;

// ***************** comando Find		DISTINGUERE tra parametri in pos 0 (estensioni) e 1 (percorsi)
comm_find_stmt	::= Com_Find param:x	{: 
					Utility.mf("_FIND_!");
					parser.comFind = new FINDCommand(parser.getEnviroment());

//					parser.counter_file = 0; //posso usare una arraylist e poi convertire in array
//					parser.counter_path = 0;

					parser.add_param(x);
					:}
		| Com_Find i_cc_conds
		
		| comm_find_stmt param:x
					{:
					Utility.mf("passo dentro comm_find_stmt");
					parser.add_param(x);
					:}
		| comm_find_stmt i_cc_conds
		| comm_find_stmt Com_Ex comm_find_stmt_2 Pv
;

comm_find_stmt_2
		::= commands:sc		{:
					Utility.mf("COMANDO RICORSIVO! rilevato: "+sc);
					parser.cpm[5] = new CommandParameter[]{new CommandParameter(null,sc,null)};
					:}
		| comm_find_stmt_2 Name param:p  
					{:
					Utility.mf("COMANDO RECURSIVO! rilevato:  CON PARAM"); 
					parser.cp[3]=p; 
					:}	//il parametro 2(path src) è già passato dal comando find, in questa condizione è logico solo il param dst
		| comm_find_stmt_2 Name {:
					Utility.mf("COMANDO RECURSIVO! rilevato: SENZA PARAM!"); 
					:}
;
// ***************** condizioni per i comandi
_where		::= 
		| Where
;

i_cc_conds	::= cc_conds
		| i_cc_conds bool_op cc_conds
;
		

cc_conds	::=  cc_permission_cond:x
					{:
					parser.array_perm.add(parser.cp[5]);
//					parser.cp[5] = null;
					:}
		| cc_date_cond:x	{:
					parser.array_data.add(parser.cp[4]);
					:}
		| cc_dimension_cond:x	{:
					parser.array_dim.add(parser.cp[6]);
					:}

;

//dimensione, utilizzati solo in find
cc_dimension_cond ::=
		  _where Dimension_Criteria Min i_arg:a 	{: 
								Utility.mf("Dimension Criteria raccolto valore i_arg ricevuto: "+a.getStringValue());
								parser.cp[6]=new CommandParameter(ParamType.DIMENSIONE,a.getStringValue(),SignType.MIN);		
								:}
		| _where Dimension_Criteria Magg i_arg:a	{: 
								Utility.mf("Dimension Criteria raccolto");
								parser.cp[6]=new CommandParameter(ParamType.DIMENSIONE,a.getStringValue(),SignType.MAG);		
								:}
		| _where Dimension_Criteria Minug i_arg:a	{: 
								Utility.mf("Dimension Criteria raccolto");
								parser.cp[6]=new CommandParameter(ParamType.DIMENSIONE,a.getStringValue(),SignType.MINUG);		
								:}
		| _where Dimension_Criteria Maggug i_arg:a	{: 
								Utility.mf("Dimension Criteria raccolto");
								parser.cp[6]=new CommandParameter(ParamType.DIMENSIONE,a.getStringValue(),SignType.MAGUG);		
								:}
		| _where Dimension_Criteria Diver i_arg:a{: 
								Utility.mf("Dimension Criteria raccolto");
								parser.cp[6]=new CommandParameter(ParamType.DIMENSIONE,a.getStringValue(),SignType.DIV);		
								:}
		| _where Dimension_Criteria C_Ug i_arg:a	{: 
								Utility.mf("Dimension Criteria raccolto OK");
								parser.cp[6]=new CommandParameter(ParamType.DIMENSIONE,a.getStringValue(),SignType.UG);		
								:}
;

//permessi
cc_permission_cond ::=
		 _where Permission_Criteria Min i_arg:a 	{: 
								Utility.mf("Dimension Criteria raccolto");
								parser.cp[5]=new CommandParameter(ParamType.PERMESSI,a.getStringValue(),SignType.MIN);
								:}

		| _where Permission_Criteria Magg i_arg:a	{: 
								Utility.mf("Dimension Criteria raccolto");
								parser.cp[5]=new CommandParameter(ParamType.PERMESSI,a.getStringValue(),SignType.MAG);		
								:}

		| _where Permission_Criteria Minug i_arg:a	{: 
								Utility.mf("Dimension Criteria raccolto");
								parser.cp[5]=new CommandParameter(ParamType.PERMESSI,a.getStringValue(),SignType.MINUG);		
								:}

		| _where Permission_Criteria Maggug i_arg:a	{: 
								Utility.mf("Dimension Criteria raccolto");
								parser.cp[5]=new CommandParameter(ParamType.PERMESSI,a.getStringValue(),SignType.MAGUG);		
								:}

		| _where Permission_Criteria Diver i_arg:a	{: 
								Utility.mf("Dimension Criteria raccolto");
								parser.cp[5]=new CommandParameter(ParamType.PERMESSI,a.getStringValue(),SignType.DIV);
								:}

		| _where Permission_Criteria C_Ug i_arg:a	{: 
								Utility.mf("Dimension Criteria raccolto permesso = : OK");
								parser.cp[5]=new CommandParameter(ParamType.PERMESSI,a.getStringValue(),SignType.UG);			
								:}
;		
//date
cc_date_cond ::=
		 _where Date_Criteria Min date_arg:a	{: 
								Utility.mf("Date Criteria MIN raccolto");
								parser.cp[4]=new CommandParameter(ParamType.DATA,a,SignType.MIN);					
							:}
		| _where Date_Criteria Magg date_arg:a	{: 
								Utility.mf("Date Criteria MAG raccolto");
								parser.cp[4]=new CommandParameter(ParamType.DATA,a,SignType.MAG);					
								:}
		| _where Date_Criteria Minug date_arg:a		{: 
								Utility.mf("Date Criteria MINUG raccolto");
								parser.cp[4]=new CommandParameter(ParamType.DATA,a,SignType.MINUG);					
								:}
		| _where Date_Criteria Maggug date_arg:a	{: 
								Utility.mf("Date Criteria MAGUG raccolto");
								parser.cp[4]=new CommandParameter(ParamType.DATA,a,SignType.MAGUG);					
								:}
		| _where Date_Criteria Diver date_arg:a		{: 
								Utility.mf("Date Criteria DIV raccolto");
								parser.cp[4]=new CommandParameter(ParamType.DATA,a,SignType.DIV);					
								:}
		| _where Date_Criteria C_Ug date_arg:a		{: 
								Utility.mf("Date Criteria UG raccolto");
								parser.cp[4]=new CommandParameter(ParamType.DATA,a,SignType.UG);					
								:}
;


bool_op		::= C_And:x 	{: RESULT =x; :}
		| C_Or:x 	{: RESULT =x; :}
;

// ***************** argomento data
date_arg	::= Data:x	{: RESULT = x;	:}
;
// ***************** argomento generico

	//GMA:x	{: RESULT = new myVar(myVar._string, x);			:}
i_arg		::= Int:x	{: RESULT = new myVar(myVar._int, x.intValue()); 		:}
		| Vint:x	{: RESULT= new myVar(myVar._float, x.floatValue()); 		:}
		| Str:x		{: System.out.println("str: "+x); 
					RESULT= new myVar(myVar._string, x); 			:}
		| IUnit:x	{: RESULT= new myVar(myVar._string, x); 			:}//verificare la dimensione
		| FUnit:x	{: RESULT= new myVar(myVar._string, x); 			:}
		| Bool:x	{: RESULT= new myVar(myVar._bool, new Boolean(x)); 		:}
;


// ***************** espressione booleana

cond_if		::= C_Orr:s {: 
				Utility.mf("IF C_Orr: ");
				RESULT = s; :}
		| C_Andd:s {: RESULT = s; :}
;

conf		::= arit_stmt cond arit_stmt 
				{:
				
				:}
/*		| arit_stmt cond_if arit_stmt*/
;

conf_exp	::= conf
		| logic_stmt:s	
				{:
				Utility.mf("IF LOGIC STMT -> CONF_EXP ");
				RESULT = s;
				:}
		| C_Not conf
/*		| conf cond_if conf*/
		| conf_exp cond_if conf
		| conf_exp cond_if arit_stmt
		| conf_exp:x cond_if:s logic_stmt:y
				{:
				Utility.mf("IF: CONF_EXP with AND/OR ...");
				RESULT = parser.vm.makeOper(x,y,s);
				:}
;


//not_exp		::= C_Not Var 
//		| C_Not i_arg
//;


// **************** IF statement

if_head		::= Com_If conf_exp:x Com_If_2 EL i_stmt:l
				{:
				if_command ic = new if_command(x);
				ic.set_list_command(l);
				parser.list_script.clear();
				Utility.mf("IF HEAD condizione: ");
				Utility.mf("\tSUBLEVEL: "+parser.sublevel);
				RESULT = ic;
				:}
;

if_stmt		::= if_head:x Com_If_m EL i_stmt:l Com_If_e
				{:
				x.set_list_command_else(l);
				parser.list_script.clear();
				x.close_command(new myVar());
				Utility.mf("IF ELSE CHIUSO");
				RESULT = x;
				:}
		| if_head:x Com_If_e
				{:
				x.close_command();
				Utility.mf("IF CHIUSO");
				RESULT = x;
				:}
;

// **************** FOREACH statement

for_arg		::= Var:x	{: RESULT = parser.vm.extractVar(x); 
					System.out.println("Var: "+x); :}
		| Int:x		{: RESULT = new myVar(myVar._int, x.intValue()); 	:}
		| Vint:x	{: RESULT= new myVar(myVar._float, x.floatValue()); 	:}
		| ID:x		{: RESULT= new myVar(myVar._string, x); :}
;

for_head	::= Com_For for_arg:x for_arg:y for_arg:z Com_For_m EL
				{:
				System.out.println("FOR HEAD variabili "+x.getValue()+"\t"+y.getValue()+"\t"+z.getValue());
				for_command fc = new for_command(x,y,z,parser.vm);
				Utility.mf("\tSUBLEVEL: "+(++parser.sublevel));
				RESULT = fc;
				:}
;

i_Op_ps		::= Plus:x	{: RESULT = x; 						:}
		| Minus:x	{: RESULT = x; 						:}
;


//check if minus is passed for value step
for_tail 	::= Com_For_e i_Op_ps:s for_arg:y 
				{: 
				Utility.mf("CICLO FOR CHIUSO");
				Utility.mf("\tSUBLEVEL: "+(--parser.sublevel));
				Utility.mf("step: "+parser.vm.Auto_Neg(y,s));
				RESULT = parser.vm.Auto_Neg(y,s);
				:}
;

for_stmt	::= for_head:x i_stmt:l for_tail:y
		{:
		x.set_list_command(l);
		parser.list_script.clear();
		x.close_command(y);
		System.out.println("for cycle");
		RESULT = x;
		:}
;


