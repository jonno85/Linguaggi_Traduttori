package it.polito.lt.skype.generated.parser;


import java_cup.runtime.*;
import java.io.InputStreamReader;
import java.util.HashMap;
import java.util.Collection;
import java.util.Iterator;
import java.util.Calendar;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Iterator;
import it.polito.lt.skype.manager.*;
import it.polito.lt.skype.command.*;
import it.polito.lt.skype.parser.*;
import it.polito.lt.skype.bot.*;


init with {:
	vm = new VarManager();
	cp = new CommandParameter[7];
	cpm = new CommandParameter[7][];
	com = null;
	comFind = null;

	array_path = new ArrayList<CommandParameter>();
	array_file = new ArrayList<CommandParameter>();
	array_perm = new ArrayList<CommandParameter>();
	array_data = new ArrayList<CommandParameter>();
	array_dim = new ArrayList<CommandParameter>();

	ifcc = null;
	ic = null;

	//list_script = new LinkedList<ICommand>();
	todo = new LinkedList<ICommand>();

	token_list = new ArrayList<String>();

:}

parser code {:

	public VarManager vm;
	public CommandParameter[] cp, datap, permp, dimp ;
	public CommandParameter[][] cpm;
	public ICommand com, comFind;
	//public int counter_file = 0;
	//public int counter_path = 0;
	//public int sublevel = 0;

	public ArrayList<CommandParameter> array_path, array_file, array_dim, array_perm, array_data;

	public ArrayList<String> token_list;

	public ArrayList<ASCommand> dec_list;

	public LinkedList<ICommand> list_script;
	public LinkedList<ICommand> todo;
	public IFlowCommandControl ifcc;
	public ICommand ic;
	public boolean if_control = false;
	
	public boolean script_enabled=false;	
	public CScript csc=null;	

	private String enviroment = "/home/robizz";

	public void add_param(CommandParameter x) throws ParserException
	{
		//Utility.mf(x.getValue()+" tipo "+x.getParamType());
		if(x.getParamType()==ParamType.PATH)
			array_path.add(x);
		else
			array_file.add(x);
	}

	public void setEnviroment(String path)
	{
		enviroment = path;
		Utility.mf("CURRENT-PATH now is: " + enviroment);
	}

	public String getEnviroment()
	{
		return enviroment;
	}

	public void print_el(LinkedList<ICommand> ls)
	{
		
		//Utility.mf("ITERATORE di una lista da: "+ls.size());
		//for(ICommand i: ls){
		//	Utility.mf("==elemento");
		//	i.toString();
		//}
	}
:}
;


terminal String		Com_Ex, Com_Find, Com_Rm, Com_MKDir, Com_Cp, Com_Cd, Com_If, Com_If_2, Com_If_m, Com_If_e, Com_For, Com_For_e, Com_For_m, Com_Ls, Com_Str, Com_Mov, Com_P;
terminal String		Ext, ID, File, Path, Order,Data ,Month, Day, Date_Criteria,Permission_Criteria,Dimension_Criteria, Obj, Where, Prep_supp, Min,Magg,Minug,Maggug,Diver, C_Ug, C_And, C_Or, C_Ugg, C_Andd, C_Orr, C_Not, SO, SC, RO, RC, Minus, Plus, Times,Div, FUnit, IUnit, Minor, Pv, Name, Result, Throw_S, Start_S, End_S, Str, FileScript, EL;
terminal Integer	Int;
terminal Float		Vint;
terminal 		UMINUS;
terminal Boolean	Bool;
terminal String		Var;


non terminal		S;

non terminal		i_conds, bool_exp, _where, cond, comm_find_stmt, comm_find_stmt_2, i_cc_conds,cc_date_cond, cc_permission_cond, cc_dimension_cond ,cc_conds;
non terminal myVar	i_arg,  logic_stmt;
non terminal String		arit_arg, commands,i_Op, i_Op_ps, start_s, throw_s, end_s, bool_op, conf,date_arg, conf_exp, arit_stmt,for_arg, for_tail;
non terminal Object[]		LS_stmt;
//non terminal Calendar		date_arg;
non terminal CommandParameter	param;
non terminal for_command	for_stmt, for_head;
non terminal if_command		if_stmt, if_head, if_head_half, if_else;
non terminal LinkedList		i_stmt;
non terminal CScript		script;
non terminal ICommand		sh_stmt, init_stmt, stmt, str_stmt,print_stmt;
non terminal ASCommand		assig_stmt;


precedence left Minus, Plus, C_Or, C_Orr;
precedence left Div, Times, C_And, C_Andd;
precedence left C_Not;
precedence left UMINUS;

start with S;

// elemento radice

S 		::= 	/* empty */
		| i_stmt
;

// ********************* script

script		::= start_s i_stmt:x end_s
					{:
					parser.script_enabled=false;					
					//Utility.mf("CHIUDO SCRIPT");
					//salvataggio script
								
					//esecuzione script
					
					:}
;

// ********************* comandi di gestione script

start_s			::= Start_S File:s EL
					{:
					//Utility.mf("INIZIO SCRIPT");
					parser.script_enabled=true;					
					parser.list_script = new LinkedList<ICommand>();
					parser.csc=new CScript((LinkedList<ICommand>)parser.list_script, parser.vm);							
					parser.vm=parser.csc.getScriptVM();
					//parser.list_script.add(s);
					:}
;

throw_s		::= Throw_S File	{:
					Utility.mf("LANCIA SCRIPT---------------------------------------------------------------------------------");
					parser.csc.exec();
					//Utility.mf("LANCIA SCRIPT");
					:}
;

end_s		::= End_S File:s
					{:
					//ripristino vm originale
					parser.vm = parser.csc.getBakVm();
					//Utility.mf("VARMANAGER: "+parser.vm);
					:}
;

// ********************* insieme di statement

i_stmt		::= stmt:s		{://RE-Init
					parser.todo.add(s);
					
					parser.cp = new CommandParameter[7];
					parser.cpm = new CommandParameter[7][];
					parser.com = null;
					parser.comFind = null;
					:}
		| i_stmt stmt:s		{:
					parser.todo.add(s);
					//parser.list_script.add(s);
					:}
;

// ********************* statemente generali

stmt 		::= init_stmt:s EL	{://Utility.mf("stmt: init_stmt: lista dichiar: "+parser.dec_list.toString());
					DecCommand dc = new DecCommand(parser.dec_list);
					parser.list_script.add(dc);
					
					:}
		| assig_stmt:s EL	{:
					parser.list_script.add(s);
					//Utility.mf("AGGIUNGO ASSIST STMT: "+((s==null)?"null ":"no "+s.toString())); 
					//if(parser.vm.extractVar(s.getName())!=null){
					//	parser.vm.assig(s);
						//Utility.mf(s.toString());
					//}
					//else Utility.mf("VARIABILE INESISTENTE");
					//Utility.mf("ASSIG STMT RACCOLTO");
					RESULT = (ICommand)s; :}
		| str_stmt:s EL		{:
					parser.list_script.add(s);
					//Utility.mf("AGGIUNGO STR STMT: "+((s==null)?"null ":"no "+s.toString())); 
					RESULT = s;
					//parser.list_script.add(s);
					//Utility.mf("risolto flow control statement -> INSERITO IN LIST SCRIPT"); 
					:}
		| sh_stmt:s EL		{:

					//System.out.println("raccolto sh stmt: parameter setting"); 
					//parser.cp[0] = parser.array_file.get(0);
					//parser.cp[1] = parser.array_path.get(0);
					//parser.cp[2] = parser.array_perm.get(0);
					//parser.cp[3] = parser.array_data.get(0);
					//parser.cp[4] = parser.array_dim.get(0);
					//for(int i=0; i<7; i++)
					//	if(parser.cp[i]==null)
					//		Utility.mf("*niente*");
					//	else
					//		Utility.mf("param["+i+"]: "+parser.cp[i].getValue());
					parser.com.setCommandParameter(parser.cp);
					//ESECUZIONE SOLO IN SCRIPT O SHELL
					if(!parser.script_enabled){
						parser.com.exec();
						//Utility.mf(parser.com.getCommandStringResult());
					}
					else
						parser.list_script.add(parser.com);
					//Utility.mf("AGGIUNGO SH STMT: "+((s==null)?"null ":"no "+s.toString())); 

					:}
		| comm_find_stmt:s EL	{:
					//System.out.println("raccolto sh stmt = FIND");
					parser.cpm[0] = new CommandParameter[parser.array_file.size()];
					parser.cpm[1] = new CommandParameter[parser.array_path.size()];
					parser.cpm[2] = new CommandParameter[parser.array_perm.size()];
					parser.cpm[3] = new CommandParameter[parser.array_data.size()];
					parser.cpm[4] = new CommandParameter[parser.array_dim.size()];

					//System.out.println("dopo onit");
					parser.cpm[0] = parser.array_file.toArray(parser.cpm[0]);
					parser.cpm[1] = parser.array_path.toArray(parser.cpm[1]);
					parser.cpm[2] = parser.array_perm.toArray(parser.cpm[2]);
					parser.cpm[3] = parser.array_data.toArray(parser.cpm[3]);
					parser.cpm[4] = parser.array_dim.toArray(parser.cpm[4]);

					//parser.cpm[6]=new CommandParameter[7];

					//System.out.println("dopo init 2'");

					//Utility.mf("SETCOMMANDPARAMETER");
					parser.comFind.setCommandParameter(parser.cpm);
					if(!parser.script_enabled){
						//Utility.mf("EXEC");
						parser.comFind.exec();
						parser.array_file.clear();
						parser.array_path.clear();
						parser.array_perm.clear();
						parser.array_data.clear();
						parser.array_dim.clear();
					}
					//else
				//SISTEMAREparser.list_script.add(s);
					
					
					//Utility.mf(parser.comFind.getCommandStringResult());

					:}
		| print_stmt:p EL {:parser.list_script.add(p);:}
		| script EL {:parser.print_el(parser.list_script);:}
		| throw_s EL
		| conf_exp EL /*********************************************/
		| EL
;


print_stmt		::= Com_P arit_stmt:s {:
					PCommand pcom = new PCommand(parser.token_list, parser.vm);
					parser.token_list = new ArrayList<String>();
					RESULT =pcom;
					//RESULT = pcom;
					:}
;


// ********************* statement controllo di flusso

str_stmt	::= if_stmt:x			{: //Utility.mf("raccolto IF stmt");
						((if_command)x).print_parameters();
						//Utility.mf("raccolto IF stmt"); 
						RESULT = x;
						:}
		| for_stmt:x			{: 
						x.print_parameters(); 
						//Utility.mf("raccolto FOR stmt"); 
						RESULT = x;
						:}
//		| str_stmt for_stmt		{: Utility.mf("raccolto FOR stmt interno"); :}
//		| str_stmt if_stmt		{: Utility.mf("raccolto IF stmt interno"); :}
;

// ********************* statement di assegnazione valori

assig_stmt	::= Var:x C_Ug arit_stmt:y	{:
						//operazioni fatte in fase di parsing di script (ritorna un Icommand)
						//y.setName(parser.vm.getTempName());
						//y.setVM(parser.vm);
						//parser.vm.add_var(y);						
						ASCommand ac = new ASCommand(parser.vm, x, parser.token_list);
						
						//Utility.mf("assig_stmt raccolto: "+x+"<--"+parser.token_list.toString());
						parser.token_list = new ArrayList<String>();
						RESULT = ac;
						//operazioni fatte in fase di parsing riga di comando (ritorna un myVar)
						//myVar vx = new myVar();
						//vx.set(y);
						//vx.setName(x);
						//RESULT = vx;
						//Utility.mf("fine da arit_stmt a assig_stmt");
						:}
//		| Var:x				{:RESULT = new myVar(x,parser.vm);:}
;


// ********************* statement di inizializzazione variabili

init_stmt	::=  Com_Str assig_stmt:x
						{:
						x.setDeclaration(true);
						parser.dec_list = new ArrayList<ASCommand>();
						//Utility.mf("init_stmt: assig_stmt: "+x.toString());					
						parser.dec_list.add(x);
						:}
		| Com_Str Var:x
						{:
						parser.dec_list = new ArrayList<ASCommand>();
						parser.vm.add_var(new myVar(x,parser.vm));// Utility.mf("DICHIARAZIONI\nvar: "+x.toString());
						:}
		| init_stmt assig_stmt:x
						{:
						x.setDeclaration(true);
						//Utility.mf("init_stmt: assig_stmt: "+x.toString());	
						parser.dec_list.add(x);
						:}
		| init_stmt Var:x
						{:
						parser.vm.add_var(new myVar(x,parser.vm)); //Utility.mf("var: "+x.toString());
						:}
;

// ********************* gestione operazioni algebriche - booleane - concatenazione

arit_stmt	::= Minus:s arit_stmt:x
		{:
			parser.token_list.add("--");
		:}%prec UMINUS
		| arit_stmt:x Plus:s arit_stmt:y
		{:
			parser.token_list.add(s);
		:}
		| arit_stmt:x Times:s arit_stmt:y
		{:
			parser.token_list.add(s);
		:}
		| arit_stmt:x Div:s arit_stmt:y
		{:
			parser.token_list.add(s);
		:}
		| arit_stmt:x Minus:s arit_stmt:y
		{:
			parser.token_list.add(s);
		:}
		| arit_stmt:x C_And:s arit_stmt:y
		{:
			parser.token_list.add(s);
		:}
		| arit_stmt:x C_Or:s arit_stmt:y
		{:
			parser.token_list.add(s);
		:}
		| arit_arg:x
		{:
		parser.token_list.add(x);
		RESULT = x;
			//System.out.println("da arit_arg a arit_stmt");
		:}
		| RO arit_stmt:x RC
		| C_Not:s arit_stmt:x
		{:
		parser.token_list.add("!!");
		:}%prec C_Not
;
//qui logic erano
// ***************** argomenti che subiscono un'operazione 
// ***************** algebrica - booleana - concatenazione

arit_arg	::= Var:x			{: RESULT = x;
							//System.out.println("Var a arit_arg "+x); 
						:}
		| i_arg:x			{: 
						parser.vm.add_var(x);
						RESULT = x.getName();
		//System.out.println("i_arg a arit_arg: "+x.toString());
						:}
;

//i_Op		::= bool_op:x	{: RESULT = x; :}
//		| C_Not:x	{: RESULT = x; :}
//;


// ***************** parametri per i comandi

param		::= Path:x	{: RESULT = new CommandParameter(ParamType.PATH,x,null); :}
		| File:x	{: RESULT = new CommandParameter(ParamType.FILE,x,null); :}
		| Ext:x		{: RESULT = new CommandParameter(ParamType.FILE,x,null); :}
;

// ***************** statement relativi ai comandi

sh_stmt		::= commands:c param:p  {: parser.cp[2]=p; :}
		| commands i_cc_conds
		| sh_stmt param:p 	{: parser.cp[3]=p; :}
		| sh_stmt i_cc_conds
		//| commands_oa:x		{: RESULT = x; :}
;

// ***************** comandi standard mv, rm, cp e aggiunti cd, ls
commands	::= Com_Cd		{: 
					//Utility.mf("CD!");
					RESULT= "cd";
					parser.com = new CDCommand(parser.getEnviroment(),parser);
					:}
		//| Com_Cd Minor
		| Com_MKDir		{: 
					//Utility.mf("MKDIR!");
					RESULT= "mkdir";
					parser.com = new MKDCommand(parser.getEnviroment());
					:}

		|Com_Mov		{: 
					//Utility.mf("MV!");
					RESULT= "mv";
					parser.com = new MVCommand(parser.getEnviroment());
					:}

		| Com_Rm		{: 
					//Utility.mf("RM!");
					RESULT= "rm";
					parser.com = new RMCommand(parser.getEnviroment());
					:}

		| Com_Cp		{: 
					//Utility.mf("CP!");
					RESULT= "cp";
					parser.com = new CPCommand(parser.getEnviroment());
					:}
		| LS_stmt		{:RESULT= "ls";:}
;

LS_stmt		::= Com_Ls		{: 
					//Utility.mf("LS!");
					parser.com = new LSCommand(parser.getEnviroment());
					:}

		| LS_stmt Order:o	{: 
					//Utility.mf("LS Order!");
					parser.cp[0]=new CommandParameter(ParamType.BINARIO,o,null);
					:}
		
		| LS_stmt Obj:o		{: 
					//Utility.mf("LS obj!");
					parser.cp[1]=new CommandParameter(ParamType.BINARIO,o,null);
					:}
;

// ***************** comando Find		DISTINGUERE tra parametri in pos 0 (estensioni) e 1 (percorsi)
comm_find_stmt	::= Com_Find param:x	{: 
					//Utility.mf("_FIND_!");
					parser.comFind = new FINDCommand(parser.getEnviroment());

//					parser.counter_file = 0; //posso usare una arraylist e poi convertire in array
//					parser.counter_path = 0;

					parser.add_param(x);
					:}
		| Com_Find i_cc_conds
		
		| comm_find_stmt param:x
					{:
					//Utility.mf("passo dentro comm_find_stmt");
					parser.add_param(x);
					:}
		| comm_find_stmt i_cc_conds
		| comm_find_stmt Com_Ex comm_find_stmt_2 Pv
;

comm_find_stmt_2
		::= commands:sc		{:
					//Utility.mf("COMANDO RICORSIVO! rilevato: "+sc);
					parser.cpm[5] = new CommandParameter[]{new CommandParameter(null,sc,null)};
					:}
		| comm_find_stmt_2 Name param:p  
					{:
					//Utility.mf("COMANDO RECURSIVO! rilevato:  CON PARAM"); 
					parser.cp[3]=p; 
					:}	//il parametro 2(path src) è già passato dal comando find, in questa condizione è logico solo il param dst
		| comm_find_stmt_2 Name {:
					//Utility.mf("COMANDO RECURSIVO! rilevato: SENZA PARAM!"); 
					:}
;
// ***************** condizioni per i comandi
_where		::= 
		| Where
;

i_cc_conds	::= cc_conds
		| i_cc_conds bool_op cc_conds
;
		

cc_conds	::=  cc_permission_cond:x
					{:
					parser.array_perm.add(parser.cp[5]);
//					parser.cp[5] = null;
					:}
		| cc_date_cond:x	{:
					parser.array_data.add(parser.cp[4]);
					:}
		| cc_dimension_cond:x	{:
					parser.array_dim.add(parser.cp[6]);
					:}

;

//dimensione, utilizzati solo in find
cc_dimension_cond ::=
		  _where Dimension_Criteria Min i_arg:a 	{: 
								//Utility.mf("Dimension Criteria raccolto valore i_arg ricevuto: "+a.getStringValue());
								parser.cp[6]=new CommandParameter(ParamType.DIMENSIONE,a.getStringValue(),SignType.MIN);		
								:}
		| _where Dimension_Criteria Magg i_arg:a	{: 
								//Utility.mf("Dimension Criteria raccolto");
								parser.cp[6]=new CommandParameter(ParamType.DIMENSIONE,a.getStringValue(),SignType.MAG);		
								:}
		| _where Dimension_Criteria Minug i_arg:a	{: 
								//Utility.mf("Dimension Criteria raccolto");
								parser.cp[6]=new CommandParameter(ParamType.DIMENSIONE,a.getStringValue(),SignType.MINUG);		
								:}
		| _where Dimension_Criteria Maggug i_arg:a	{: 
								//Utility.mf("Dimension Criteria raccolto");
								parser.cp[6]=new CommandParameter(ParamType.DIMENSIONE,a.getStringValue(),SignType.MAGUG);		
								:}
		| _where Dimension_Criteria Diver i_arg:a{: 

								//Utility.mf("Dimension Criteria raccolto");
								parser.cp[6]=new CommandParameter(ParamType.DIMENSIONE,a.getStringValue(),SignType.DIV);		
								:}
		| _where Dimension_Criteria C_Ug i_arg:a	{: 
								//Utility.mf("Dimension Criteria raccolto OK");
								parser.cp[6]=new CommandParameter(ParamType.DIMENSIONE,a.getStringValue(),SignType.UG);		
								:}
;

//permessi
cc_permission_cond ::=
		 _where Permission_Criteria Min i_arg:a 	{: 
								//Utility.mf("Dimension Criteria raccolto");
								parser.cp[5]=new CommandParameter(ParamType.PERMESSI,a.getStringValue(),SignType.MIN);
								:}

		| _where Permission_Criteria Magg i_arg:a	{: 
								//Utility.mf("Dimension Criteria raccolto");
								parser.cp[5]=new CommandParameter(ParamType.PERMESSI,a.getStringValue(),SignType.MAG);		
								:}

		| _where Permission_Criteria Minug i_arg:a	{: 
								//Utility.mf("Dimension Criteria raccolto");
								parser.cp[5]=new CommandParameter(ParamType.PERMESSI,a.getStringValue(),SignType.MINUG);		
								:}

		| _where Permission_Criteria Maggug i_arg:a	{: 
								//Utility.mf("Dimension Criteria raccolto");
								parser.cp[5]=new CommandParameter(ParamType.PERMESSI,a.getStringValue(),SignType.MAGUG);		
								:}

		| _where Permission_Criteria Diver i_arg:a	{: 
								//Utility.mf("Dimension Criteria raccolto");
								parser.cp[5]=new CommandParameter(ParamType.PERMESSI,a.getStringValue(),SignType.DIV);
								:}

		| _where Permission_Criteria C_Ug i_arg:a	{: 
								//Utility.mf("Dimension Criteria raccolto permesso = : OK");
								parser.cp[5]=new CommandParameter(ParamType.PERMESSI,a.getStringValue(),SignType.UG);			
								:}
;		
//date
cc_date_cond ::=
		 _where Date_Criteria Min date_arg:a	{: 
								//Utility.mf("Date Criteria MIN raccolto");
								parser.cp[4]=new CommandParameter(ParamType.DATA,a,SignType.MIN);					
							:}
		| _where Date_Criteria Magg date_arg:a	{: 
								//Utility.mf("Date Criteria MAG raccolto");
								parser.cp[4]=new CommandParameter(ParamType.DATA,a,SignType.MAG);					
								:}
		| _where Date_Criteria Minug date_arg:a		{: 
								//Utility.mf("Date Criteria MINUG raccolto");
								parser.cp[4]=new CommandParameter(ParamType.DATA,a,SignType.MINUG);					
								:}
		| _where Date_Criteria Maggug date_arg:a	{: 
								//Utility.mf("Date Criteria MAGUG raccolto");
								parser.cp[4]=new CommandParameter(ParamType.DATA,a,SignType.MAGUG);					
								:}
		| _where Date_Criteria Diver date_arg:a		{: 
								//Utility.mf("Date Criteria DIV raccolto");
								parser.cp[4]=new CommandParameter(ParamType.DATA,a,SignType.DIV);					
								:}
		| _where Date_Criteria C_Ug date_arg:a		{: 
								//Utility.mf("Date Criteria UG raccolto");
								parser.cp[4]=new CommandParameter(ParamType.DATA,a,SignType.UG);					
								:}
;


bool_op		::= C_And:x 	{: RESULT =x; :}
		| C_Or:x 	{: RESULT =x; :}
;

// ***************** argomento data
date_arg	::= Data:x	{: RESULT = x;	:}
;
// ***************** argomento generico


i_arg		::= Int:x	{: RESULT = new myVar(parser.vm.getTempName(), myVar._int, x); 		:}
		| Vint:x	{: RESULT = new myVar(parser.vm.getTempName(), myVar._float, x); 		:}
		| Str:x		{: RESULT = new myVar(parser.vm.getTempName(), myVar._string, x); 			:}
		| IUnit:x	{: RESULT = new myVar(parser.vm.getTempName(), myVar._string, x); 			:}//verificare la dimensione
		| FUnit:x	{: RESULT = new myVar(parser.vm.getTempName(), myVar._string, x); 			:}
		| Bool:x	{: RESULT = new myVar(parser.vm.getTempName(), myVar._bool, x); 		:}
;


// ***************** espressione booleana

conf_exp	::= logic_stmt:s
				{:
				//Utility.mf("IF LOGIC STMT -> CONF_EXP ");
				:}
		| conf_exp:x C_Orr:s conf_exp:y
				{:
				parser.token_list.add(s);
				:}
		| conf_exp:x C_Andd:s conf_exp:y
				{:
				parser.token_list.add(s);
				:}
		| RO conf_exp:x RC
		| C_Not:s conf_exp
				{:
				parser.token_list.add(s);
				:}%prec C_Not
;




//statement logici


logic_stmt	::= arit_stmt:x Magg:s arit_stmt:y
		{:
			parser.token_list.add(s);
		:}
		| arit_stmt:x Maggug:s arit_stmt:y
		{:
			parser.token_list.add(s);
		:}
		| arit_stmt:x Min:s arit_stmt:y
		{:
			parser.token_list.add(s);
		:}
		| arit_stmt:x Minug:s arit_stmt:y
		{:
			parser.token_list.add(s);
		:}
		| arit_stmt:x C_Ugg:s arit_stmt:y
		{:
			parser.token_list.add(s);
		:} 
		| arit_stmt:x Diver:s arit_stmt:y
		{:
			parser.token_list.add(s);
		:}
;

//not_exp		::= C_Not Var 
//		| C_Not i_arg
//;


// **************** IF statement

if_head		::= Com_If conf_exp Com_If_2 EL 
				{:
				Resolver res = new Resolver(parser.vm, parser.token_list, "if_tmp_");
				if_command ic = new if_command(parser.vm, parser.token_list);
				parser.token_list = new ArrayList<String>();

				//Utility.mf("IF HEAD: "+x.toString());
				//ic.set_list_command(l);
				//parser.list_script.clear();
				//Utility.mf("IF HEAD condizione: ");
				//Utility.mf("\tSUBLEVEL: "+parser.sublevel);
				//Utility.mf("LISTA GENERALE?: "+((parser.list_script==null)?"si":"no"));
				ic.setBackupCommand(parser.list_script);

				parser.list_script = ic.getInsideCommand();
				//Utility.mf("associata lista interna if");
				RESULT = ic;
				:}
;

if_else		::= if_head_half:x Com_If_m EL
				{:
				parser.list_script = x.getElseCommand();
				RESULT = x;
				:}
;

if_head_half	::= if_head:x i_stmt:l
				{:
				RESULT = x;
				:}
;

if_stmt		::= if_else:x i_stmt:l Com_If_e
				{:
				//x.set_list_command_else(l);
				//parser.list_script.clear();
				//x.close_command(new myVar());
				//Utility.mf("IF ELSE: CHIUSO");
				parser.list_script = x.getBackupCommand();
				x.print_parameters();
				RESULT = x;
				:}
		| if_head_half:x Com_If_e
				{:
				//x.close_command();
				//Utility.mf("IF: CHIUSO");
				//Utility.mf("LISTA IF?: "+((parser.list_script==null)?"si":"no"));
				parser.list_script = x.getBackupCommand();
				//Utility.mf("LISTA GENERALE?: "+((parser.list_script==null)?"si":"no"));
				//x.print_parameters();
				RESULT = x;
				:}
;

// **************** FOREACH statement

for_arg		::= Var:x	{: RESULT = x;			:}
		| Int:x		{: 	myVar m = new myVar(parser.vm.getTempName(),myVar._int, x.intValue());
					parser.vm.add_var(m);
					RESULT = m.getName(); 	
				:}
		| Vint:x	{: 	myVar m = new myVar(parser.vm.getTempName(),myVar._float, x.floatValue());
					parser.vm.add_var(m);
					RESULT = m.getName(); 	
				:}
		| ID:x		{: 	myVar m = new myVar(parser.vm.getTempName(),myVar._string, x);
					parser.vm.add_var(m);
					RESULT = m.getName();		
				:}
;

for_head	::= Com_For for_arg:x for_arg:y for_arg:z Com_For_m EL
				{:
				//System.out.println("FOR HEAD variabili "+x+"\t"+y+"\t"+z);

				for_command fc = new for_command(x,y,z,parser.vm);

				fc.setBackupCommand(parser.list_script);
				parser.list_script=fc.getInsideCommand();
				//Utility.mf("\tSUBLEVEL: "+(++parser.sublevel));
				RESULT = fc;
				:}
;

i_Op_ps		::= Plus:x	{: RESULT = x; 						:}
		| Minus:x	{: RESULT = x; 						:}
;



//check if minus is passed for value step
for_tail 	::= Com_For_e i_Op_ps:s for_arg:y 
				{: 
				//Utility.mf("CICLO FOR CHIUSO");
				RESULT = parser.vm.Auto_Neg(y,s);
				:}
;

for_stmt	::= for_head:x i_stmt:l for_tail:y
		{:
		parser.list_script = x.getBackupCommand();		
		x.close_command(y);
		//System.out.println("for cycle");
		RESULT = x;
		:}
;




