//package it.polito.lt.skype.generated.parser;


import java_cup.runtime.*;
//import java.io.InputStreamReader;
//import java.util.HashMap;
//import java.util.Collection;
//import java.util.Iterator;
//import java.util.Calendar;
//import java.util.ArrayList;
//import java.util.LinkedList;
//import java.util.Iterator;
//import it.polito.lt.skype.manager.*;
//import it.polito.lt.skype.command.*;
//import it.polito.lt.skype.parser.*;
//import it.polito.lt.skype.bot.*;


init with {:/*
	vm = new VarManager();
	cp = new CommandParameter[7];
	cpm = new CommandParameter[7][];
	com = null;
	comFind = null;

	array_path = new ArrayList<CommandParameter>();
	array_file = new ArrayList<CommandParameter>();
	array_perm = new ArrayList<CommandParameter>();
	array_data = new ArrayList<CommandParameter>();
	array_dim = new ArrayList<CommandParameter>();

	ifcc = null;
	ic = null;

	//list_script = new LinkedList<ICommand>();
	todo = new LinkedList<ICommand>();

*/:}

parser code {:/*

	public VarManager vm;
	public CommandParameter[] cp, datap, permp, dimp ;
	public CommandParameter[][] cpm;
	public ICommand com, comFind;
	public int counter_file = 0;
	public int counter_path = 0;
	public int sublevel = 0;

	public ArrayList<CommandParameter> array_path, array_file, array_dim, array_perm, array_data;

	public LinkedList<ICommand> list_script;
	public LinkedList<ICommand> todo;
	public IFlowCommandControl ifcc;
	public ICommand ic;
	public boolean if_control = false;

	private String enviroment = "/home";

	public void add_param(CommandParameter x) throws ParserException
	{
		Utility.mf(x.getValue()+" tipo "+x.getParamType());
		if(x.getParamType()==ParamType.PATH)
			array_path.add(x);
		else
			array_file.add(x);
	}

	public void setEnviroment(String path)
	{
		enviroment = path;
		Utility.mf("CURRENT-PATH now is: " + enviroment);
	}

	public String getEnviroment()
	{
		return enviroment;
	}

	public void print_el(LinkedList<ICommand> ls)
	{
		
		Utility.mf("ITERATORE di una lista da: "+ls.size());
		for(ICommand i: ls){
			Utility.mf("==elemento");
			i.toString();
		}
	}
*/:}
;


terminal Com_Ex, Com_Find, Com_Rm, Com_MKDir, Com_Cp, Com_Cd, Com_If, Com_If_2, Com_If_m, Com_If_e, Com_For, Com_For_e, Com_For_m, Com_Ls, Com_Str, Com_Mov, Com_P;
terminal Ext, ID, File, Path, Order,Data ,Month, Day, Date_Criteria,Permission_Criteria,Dimension_Criteria, Obj, Where, Prep_supp, Min,Magg,Minug,Maggug,Diver, C_Ug, C_And, C_Or, C_Ugg, C_Andd, C_Orr, C_Not, SO, SC, RO, RC, Minus, Plus, Times,Div, FUnit, IUnit, Minor, Pv, Name, Result, Throw_S, Start_S, End_S, Str, FileScript, EL;
terminal Int;
terminal Vint;
terminal GMA;
terminal UMINUS;
terminal Bool;
terminal Var;


non terminal		S;

non terminal		i_conds, bool_exp, _where, cond, comm_find_stmt, comm_find_stmt_2, i_cc_conds,cc_date_cond, cc_permission_cond, cc_dimension_cond ,cc_conds, script;
non terminal i_arg, assig_stmt, arit_stmt, for_arg, arit_arg, conf_exp, logic_stmt, for_tail;
non terminal commands,i_Op, i_Op_ps, start_s, throw_s, end_s, bool_op, conf,date_arg, cond_if;
non terminal sh_stmt, LS_stmt;
//non terminal date_arg;
non terminal param;
non terminal for_stmt, for_head;
non terminal if_stmt, if_head, if_head_half, if_else;
non terminal i_stmt;
non terminal init_stmt, stmt, str_stmt;



precedence left Minus, Plus, C_Or;
precedence left Div, Times, C_And;
precedence left C_Not;
precedence left UMINUS;

start with S;

// elemento radice

S 		::= 	/* empty */
		| i_stmt
;

// ********************* script

script		::= start_s i_stmt:x end_s
					{:/*
					Utility.mf("CHIUDO SCRIPT");
					//salvataggio script
					*/:}
;

// ********************* comandi di gestione script

start_s			::= Start_S File:s EL
					{:/*
					Utility.mf("INIZIO SCRIPT");
					parser.list_script = new LinkedList<ICommand>();
					//parser.list_script.add(s);
					*/:}
;

throw_s		::= Throw_S File
;

end_s		::= End_S File:s
					{:/*
					Utility.mf("FINE SCRIPT");
					*/:}
;

// ********************* insieme di statement

i_stmt		::= stmt:s		{:/*//RE-Init
					parser.todo.add(s);
					
					parser.cp = new CommandParameter[7];
					parser.cpm = new CommandParameter[7][];
					parser.com = null;
					parser.comFind = null;
					*/:}
		| i_stmt stmt:s		{:/*
					parser.todo.add(s);
					//parser.list_script.add(s);
					*/:}
;

// ********************* statemente generali

stmt 		::= init_stmt:x EL	{:/*  Utility.mf("INIT STMT RACCOLTO");	*/:} //parser.vm.getListVar();
		| assig_stmt:x EL	{:/*
					parser.list_script.add(s);
					Utility.mf("AGGIUNGO ASSIST STMT: "+((s==null)?"null ":"no "+s.toString())); 
					if(parser.vm.extractVar(x.getName())!=null){
						parser.vm.assig(x);
						Utility.mf(x.toString());
					}
					else Utility.mf("VARIABILE INESISTENTE");
					Utility.mf("ASSIG STMT RACCOLTO");
					RESULT = (ICommand)x; */:}
		| str_stmt:s EL		{:/*
					parser.list_script.add(s);
					Utility.mf("AGGIUNGO STR STMT: "+((s==null)?"null ":"no "+s.toString())); 
					RESULT = s;
					//parser.list_script.add(s);
					Utility.mf("risolto flow control statement -> INSERITO IN LIST SCRIPT"); 
					*/:}
		| sh_stmt:s EL		{:/*

					System.out.println("raccolto sh stmt: parameter setting"); 
					parser.cp[0] = parser.array_file.get(0);
					parser.cp[1] = parser.array_path.get(0);
					parser.cp[2] = parser.array_perm.get(0);
					parser.cp[3] = parser.array_data.get(0);
					parser.cp[4] = parser.array_dim.get(0);
					for(int i=0; i<7; i++)
						if(parser.cp[i]==null)
							Utility.mf("*niente*");
						else
							Utility.mf("param["+i+"]: "+parser.cp[i].getValue());
					parser.com.setCommandParameter(parser.cp);
//					ESECUZIONE SOLO IN SCRIPT O SHELL
//					if(script)
					parser.com.exec();
					Utility.mf(parser.com.getCommandStringResult());

					parser.list_script.add(s);
					Utility.mf("AGGIUNGO SH STMT: "+((s==null)?"null ":"no "+s.toString())); 

					*/:}
		| comm_find_stmt EL	{:/*
					System.out.println("raccolto sh stmt = FIND");
					parser.cpm[0] = new CommandParameter[parser.array_file.size()];
					parser.cpm[1] = new CommandParameter[parser.array_path.size()];
					parser.cpm[2] = new CommandParameter[parser.array_perm.size()];
					parser.cpm[3] = new CommandParameter[parser.array_data.size()];
					parser.cpm[4] = new CommandParameter[parser.array_dim.size()];

					System.out.println("dopo onit");
					parser.cpm[0] = parser.array_file.toArray(parser.cpm[0]);
					parser.cpm[1] = parser.array_path.toArray(parser.cpm[1]);
					parser.cpm[2] = parser.array_perm.toArray(parser.cpm[2]);
					parser.cpm[3] = parser.array_data.toArray(parser.cpm[3]);
					parser.cpm[4] = parser.array_dim.toArray(parser.cpm[4]);

					//parser.cpm[6]=new CommandParameter[7];

					System.out.println("dopo init 2'");

					Utility.mf("SETCOMMANDPARAMETER");
					parser.comFind.setCommandParameter(parser.cpm);
					Utility.mf("EXEC");
					parser.comFind.exec();
					parser.array_file.clear();
					parser.array_path.clear();
					parser.array_perm.clear();
					parser.array_data.clear();
					parser.array_dim.clear();
					
					Utility.mf(parser.comFind.getCommandStringResult());
					*/:}
		| script EL {:/*parser.print_el(parser.list_script);*/:}
		| throw_s EL
		| Com_P arit_stmt EL
		| conf_exp EL /*********************************************/
		| EL
;

// ********************* statement controllo di flusso

str_stmt	::= if_stmt:x			{:/* //Utility.mf("raccolto IF stmt");
						((if_command)x).print_parameters();
						Utility.mf("raccolto IF stmt"); 
						RESULT = x;
						*/:}
		| for_stmt:x			{:/* 
						//x.print_parameters(); nullpointerexc
						Utility.mf("raccolto FOR stmt"); 
						RESULT = x;
						*/:}
//		| str_stmt for_stmt		{:/* Utility.mf("raccolto FOR stmt interno"); */:}
//		| str_stmt if_stmt		{:/* Utility.mf("raccolto IF stmt interno"); */:}
;

// ********************* statement di assegnazione valori

assig_stmt	::= Var:x C_Ug arit_stmt:y	{:/*                                              
						myVar vx = new myVar();
						vx.set(y);
						vx.setName(x); 											
						RESULT = vx;
						//Utility.mf("fine da arit_stmt a assig_stmt");
						*/:}
//		| Var:x				{:/*RESULT = new myVar(x);*/:}
;

// ********************* statement di inizializzazione variabili

init_stmt	::=  Com_Str assig_stmt:x	{:/* parser.vm.add_var(x); Utility.mf("DICHIARAZIONI:\nassegnazione: "+x.toString()); */:}
		| Com_Str Var:x			{:/* parser.vm.add_var(new myVar(x)); Utility.mf("DICHIARAZIONI\nvar: "+x.toString());*/:}
		| init_stmt assig_stmt:x	{:/* parser.vm.add_var(x);Utility.mf("assegnazione: "+x.toString());*/:}
		| init_stmt Var:x		{:/* parser.vm.add_var(new myVar(x)); Utility.mf("var: "+x.toString());*/:}
;

// ********************* gestione operazioni algebriche - booleane - concatenazione

arit_stmt	::=	Minus:s arit_stmt:x		{:/* RESULT = parser.vm.makeOper(x,new myVar(x.getType(),new Integer(-1)),"*"); */:}%prec UMINUS
		| arit_stmt:x Times:s arit_stmt:y	
		{:/*	//System.out.println(s);
			//x.toString(); 
			//System.out.println("segno operazione: "+s); //y.toString(); 
			myVar temp = parser.vm.makeOper(((myVar)x),((myVar)y),s);
			RESULT = temp; 							*/:}
		| arit_stmt:x Div:s arit_stmt:y	
		{:/*	//System.out.println(s);
			//x.toString(); 
			//System.out.println("segno operazione: "+s); //y.toString(); 
			myVar temp = parser.vm.makeOper(((myVar)x),((myVar)y),s);
			RESULT = temp; 							*/:}
		| arit_stmt:x Plus:s arit_stmt:y	
		{:/*	//System.out.println(s);
			//x.toString(); 
			//System.out.println("segno operazione: "+s); //y.toString(); 
			myVar temp = parser.vm.makeOper(((myVar)x),((myVar)y),s);
			RESULT = temp; 							*/:}
		| arit_stmt:x Minus:s arit_stmt:y	
		{:/*	//System.out.println(s);
			//x.toString(); 
			//System.out.println("segno operazione: "+s); //y.toString(); 
			myVar temp = parser.vm.makeOper(((myVar)x),((myVar)y),s);
			RESULT = temp; 							*/:}
		| arit_stmt:x C_And:s arit_stmt:y	
		{:/*	//System.out.println(s);
			//x.toString(); 
			//System.out.println("segno operazione: "+s); //y.toString(); 
			myVar temp = parser.vm.makeOper(((myVar)x),((myVar)y),s);
			RESULT = temp; 							*/:}
		| arit_stmt:x C_Or:s arit_stmt:y	
		{:/*	//System.out.println(s);
			//x.toString(); 
			//System.out.println("segno operazione: "+s); //y.toString(); 
			myVar temp = parser.vm.makeOper(((myVar)x),((myVar)y),s);
			RESULT = temp; 							*/:}

		| arit_arg:x			{:/* RESULT = x; 
							//System.out.println("da arit_arg a arit_stmt");			
						*/:}
		| RO arit_stmt:x RC 		{:/* RESULT = x; 		*/:}
		| C_Not:s arit_stmt:x		{:/* RESULT = parser.vm.makeSOper(x,s); */:}
;
//qui logic erano
// ***************** argomenti che subiscono un'operazione 
// ***************** algebrica - booleana - concatenazione

arit_arg	::= Var:x			{:/* RESULT = parser.vm.extractVar(x); 
							//System.out.println("Var a arit_arg "+x); 
						*/:}
		| i_arg:x			{:/* RESULT = x; 
							//System.out.println("i_arg a arit_arg: "+x.toString());
							//parser.vm.add_tmp_var(x);
						*/:}
;

//i_Op		::= bool_op:x	{:/* RESULT = x; */:}
//		| C_Not:x	{:/* RESULT = x; */:}
//;


// ***************** parametri per i comandi

param		::= Path:x	{:/* RESULT = new CommandParameter(ParamType.PATH,x,null); */:}
		| File:x	{:/* RESULT = new CommandParameter(ParamType.FILE,x,null); */:}
		| Ext:x		{:/* RESULT = new CommandParameter(ParamType.FILE,x,null); */:}
;

// ***************** statement relativi ai comandi

sh_stmt		::= commands:c param:p  {:/* parser.cp[2]=p; */:}
		| commands i_cc_conds
		| sh_stmt param:p 	{:/* parser.cp[3]=p; */:}
		| sh_stmt i_cc_conds
		//| commands_oa:x		{:/* RESULT = x; */:}
;

// ***************** comandi standard mv, rm, cp e aggiunti cd, ls
commands	::= Com_Cd		{:/* 
					Utility.mf("CD!");
					RESULT= "cd";
					parser.com = new CDCommand(parser.getEnviroment(),parser);
					*/:}
		//| Com_Cd Minor
		| Com_MKDir		{:/* 
					Utility.mf("MKDIR!");
					RESULT= "mkdir";
					parser.com = new MKDCommand(parser.getEnviroment());
					*/:}

		|Com_Mov		{:/* 
					Utility.mf("MV!");
					RESULT= "mv";
					parser.com = new MVCommand(parser.getEnviroment());
					*/:}

		| Com_Rm		{:/* 
					Utility.mf("RM!");
					RESULT= "rm";
					parser.com = new RMCommand(parser.getEnviroment());
					*/:}

		| Com_Cp		{:/* 
					Utility.mf("CP!");
					RESULT= "cp";
					parser.com = new CPCommand(parser.getEnviroment());
					*/:}
		| LS_stmt		{:/*RESULT= "ls";*/:}
;

LS_stmt		::= Com_Ls		{:/* 
					Utility.mf("LS!");
					parser.com = new LSCommand(parser.getEnviroment());
					*/:}

		| LS_stmt Order:o	{:/* 
					Utility.mf("LS Order!");
					parser.cp[0]=new CommandParameter(ParamType.BINARIO,o,null);
					*/:}
		
		| LS_stmt Obj:o		{:/* 
					Utility.mf("LS obj!");
					parser.cp[1]=new CommandParameter(ParamType.BINARIO,o,null);
					*/:}
;

// ***************** comando Find		DISTINGUERE tra parametri in pos 0 (estensioni) e 1 (percorsi)
comm_find_stmt	::= Com_Find param:x	{:/* 
					Utility.mf("_FIND_!");
					parser.comFind = new FINDCommand(parser.getEnviroment());

//					parser.counter_file = 0; //posso usare una arraylist e poi convertire in array
//					parser.counter_path = 0;

					parser.add_param(x);
					*/:}
		| Com_Find i_cc_conds
		
		| comm_find_stmt param:x
					{:/*
					Utility.mf("passo dentro comm_find_stmt");
					parser.add_param(x);
					*/:}
		| comm_find_stmt i_cc_conds
		| comm_find_stmt Com_Ex comm_find_stmt_2 Pv
;

comm_find_stmt_2
		::= commands:sc		{:/*
					Utility.mf("COMANDO RICORSIVO! rilevato: "+sc);
					parser.cpm[5] = new CommandParameter[]{new CommandParameter(null,sc,null)};
					*/:}
		| comm_find_stmt_2 Name param:p  
					{:/*
					Utility.mf("COMANDO RECURSIVO! rilevato:  CON PARAM"); 
					parser.cp[3]=p; 
					*/:}	//il parametro 2(path src) è già passato dal comando find, in questa condizione è logico solo il param dst
		| comm_find_stmt_2 Name {:/*
					Utility.mf("COMANDO RECURSIVO! rilevato: SENZA PARAM!"); 
					*/:}
;
// ***************** condizioni per i comandi
_where		::= 
		| Where
;

i_cc_conds	::= cc_conds
		| i_cc_conds bool_op cc_conds
;
		

cc_conds	::=  cc_permission_cond:x
					{:/*
					parser.array_perm.add(parser.cp[5]);
//					parser.cp[5] = null;
					*/:}
		| cc_date_cond:x	{:/*
					parser.array_data.add(parser.cp[4]);
					*/:}
		| cc_dimension_cond:x	{:/*
					parser.array_dim.add(parser.cp[6]);
					*/:}

;

//dimensione, utilizzati solo in find
cc_dimension_cond ::=
		  _where Dimension_Criteria Min i_arg:a 	{:/* 
								Utility.mf("Dimension Criteria raccolto valore i_arg ricevuto: "+a.getStringValue());
								parser.cp[6]=new CommandParameter(ParamType.DIMENSIONE,a.getStringValue(),SignType.MIN);		
								*/:}
		| _where Dimension_Criteria Magg i_arg:a	{:/* 
								Utility.mf("Dimension Criteria raccolto");
								parser.cp[6]=new CommandParameter(ParamType.DIMENSIONE,a.getStringValue(),SignType.MAG);		
								*/:}
		| _where Dimension_Criteria Minug i_arg:a	{:/* 
								Utility.mf("Dimension Criteria raccolto");
								parser.cp[6]=new CommandParameter(ParamType.DIMENSIONE,a.getStringValue(),SignType.MINUG);		
								*/:}
		| _where Dimension_Criteria Maggug i_arg:a	{:/* 
								Utility.mf("Dimension Criteria raccolto");
								parser.cp[6]=new CommandParameter(ParamType.DIMENSIONE,a.getStringValue(),SignType.MAGUG);		
								*/:}
		| _where Dimension_Criteria Diver i_arg:a{:/* 
								Utility.mf("Dimension Criteria raccolto");
								parser.cp[6]=new CommandParameter(ParamType.DIMENSIONE,a.getStringValue(),SignType.DIV);		
								*/:}
		| _where Dimension_Criteria C_Ug i_arg:a	{:/* 
								Utility.mf("Dimension Criteria raccolto OK");
								parser.cp[6]=new CommandParameter(ParamType.DIMENSIONE,a.getStringValue(),SignType.UG);		
								*/:}
;

//permessi
cc_permission_cond ::=
		 _where Permission_Criteria Min i_arg:a 	{:/* 
								Utility.mf("Dimension Criteria raccolto");
								parser.cp[5]=new CommandParameter(ParamType.PERMESSI,a.getStringValue(),SignType.MIN);
								*/:}

		| _where Permission_Criteria Magg i_arg:a	{:/* 
								Utility.mf("Dimension Criteria raccolto");
								parser.cp[5]=new CommandParameter(ParamType.PERMESSI,a.getStringValue(),SignType.MAG);		
								*/:}

		| _where Permission_Criteria Minug i_arg:a	{:/* 
								Utility.mf("Dimension Criteria raccolto");
								parser.cp[5]=new CommandParameter(ParamType.PERMESSI,a.getStringValue(),SignType.MINUG);		
								*/:}

		| _where Permission_Criteria Maggug i_arg:a	{:/* 
								Utility.mf("Dimension Criteria raccolto");
								parser.cp[5]=new CommandParameter(ParamType.PERMESSI,a.getStringValue(),SignType.MAGUG);		
								*/:}

		| _where Permission_Criteria Diver i_arg:a	{:/* 
								Utility.mf("Dimension Criteria raccolto");
								parser.cp[5]=new CommandParameter(ParamType.PERMESSI,a.getStringValue(),SignType.DIV);
								*/:}

		| _where Permission_Criteria C_Ug i_arg:a	{:/* 
								Utility.mf("Dimension Criteria raccolto permesso = : OK");
								parser.cp[5]=new CommandParameter(ParamType.PERMESSI,a.getStringValue(),SignType.UG);			
								*/:}
;		
//date
cc_date_cond ::=
		 _where Date_Criteria Min date_arg:a	{:/* 
								Utility.mf("Date Criteria MIN raccolto");
								parser.cp[4]=new CommandParameter(ParamType.DATA,a,SignType.MIN);					
							*/:}
		| _where Date_Criteria Magg date_arg:a	{:/* 
								Utility.mf("Date Criteria MAG raccolto");
								parser.cp[4]=new CommandParameter(ParamType.DATA,a,SignType.MAG);					
								*/:}
		| _where Date_Criteria Minug date_arg:a		{:/* 
								Utility.mf("Date Criteria MINUG raccolto");
								parser.cp[4]=new CommandParameter(ParamType.DATA,a,SignType.MINUG);					
								*/:}
		| _where Date_Criteria Maggug date_arg:a	{:/* 
								Utility.mf("Date Criteria MAGUG raccolto");
								parser.cp[4]=new CommandParameter(ParamType.DATA,a,SignType.MAGUG);					
								*/:}
		| _where Date_Criteria Diver date_arg:a		{:/* 
								Utility.mf("Date Criteria DIV raccolto");
								parser.cp[4]=new CommandParameter(ParamType.DATA,a,SignType.DIV);					
								*/:}
		| _where Date_Criteria C_Ug date_arg:a		{:/* 
								Utility.mf("Date Criteria UG raccolto");
								parser.cp[4]=new CommandParameter(ParamType.DATA,a,SignType.UG);					
								*/:}
;


bool_op		::= C_And:x 	{:/* RESULT =x; */:}
		| C_Or:x 	{:/* RESULT =x; */:}
;

// ***************** argomento data
date_arg	::= Data:x	{:/* RESULT = x;	*/:}
;
// ***************** argomento generico

	//GMA:x	{:/* RESULT = new myVar(myVar._string, x);			*/:}
i_arg		::= Int:x	{:/* RESULT = new myVar(myVar._int, x.intValue()); 		*/:}
		| Vint:x	{:/* RESULT= new myVar(myVar._float, x.floatValue()); 		*/:}
		| Str:x		{:/* System.out.println("str: "+x); 
					RESULT= new myVar(myVar._string, x); 			*/:}
		| IUnit:x	{:/* RESULT= new myVar(myVar._string, x); 			*/:}//verificare la dimensione
		| FUnit:x	{:/* RESULT= new myVar(myVar._string, x); 			*/:}
		| Bool:x	{:/* RESULT= new myVar(myVar._bool, new Boolean(x)); 		*/:}
;


// ***************** espressione booleana

cond_if		::= C_Orr:s {:/*//Utility.mf("IF C_Orr: ");
				RESULT = s; */:}
		| C_Andd:s {:/* RESULT = s; */:}
;


conf_exp	::= //C_Not conf_exp  {:/*	RESULT = s; */:} %prec C_Not | 
logic_stmt:s	{:/*
				//Utility.mf("IF LOGIC STMT -> CONF_EXP ");
				RESULT = s;
				*/:}
		//| conf_exp cond_if arit_stmt
		| conf_exp:x cond_if:s logic_stmt:y
				{:/*
				Utility.mf("logic_stamt in confexp");
				Utility.mf(x.toString());	
				Utility.mf(s.toString());
				Utility.mf(y.toString());			
				myVar var = parser.vm.makeOper(x,y,s);
				Utility.mf("logic "+var.toString());
				RESULT=var;
				*/:}
		| RO conf_exp:x RC 		{:/* RESULT = x; 		*/:}
;




//statement logici


logic_stmt	::= arit_stmt:x Magg:s arit_stmt:y
		{:/*
			RESULT = parser.vm.makeLogicOper(x,y,s);
		*/:}
		| arit_stmt:x Maggug:s arit_stmt:y
		{:/*
			RESULT = parser.vm.makeLogicOper(x,y,s);
		*/:}
		| arit_stmt:x Min:s arit_stmt:y
		{:/*
			//Utility.mf("arit min "+x.toString()+" "+s+ " "+y.toString());		
			RESULT = parser.vm.makeLogicOper(x,y,s);
			//Utility.mf("logic "+RESULT.toString());
		*/:}
		| arit_stmt:x Minug:s arit_stmt:y
		{:/*
			RESULT = parser.vm.makeLogicOper(x,y,s);
		*/:}
		| arit_stmt:x C_Ugg:s arit_stmt:y
		{:/*
			RESULT = parser.vm.makeLogicOper(x,y,s);
		*/:} 
		| arit_stmt:x Diver:s arit_stmt:y
		{:/*
			RESULT = parser.vm.makeLogicOper(x,y,s);
		*/:}
;




//not_exp		::= C_Not Var 
//		| C_Not i_arg
//;


// **************** IF statement

if_head		::= Com_If conf_exp:x Com_If_2 EL 
				{:/*
				if_command ic = new if_command(x);
				Utility.mf("IF HEAD: "+x.toString());				
				//ic.set_list_command(l);
				//parser.list_script.clear();
				//Utility.mf("IF HEAD condizione: ");
				//Utility.mf("\tSUBLEVEL: "+parser.sublevel);
				//Utility.mf("LISTA GENERALE?: "+((parser.list_script==null)?"si":"no"));
				ic.setBackupCommand(parser.list_script);

				parser.list_script = ic.getInsideCommand();
				//Utility.mf("associata lista interna if");
				RESULT = ic;
				*/:}
;

if_else		::= if_head_half:x Com_If_m EL
				{:/*
				parser.list_script = x.getElseCommand();
				RESULT = x;
				*/:}
;

if_head_half	::= if_head:x i_stmt:l
				{:/*
				RESULT = x;
				*/:}
;

if_stmt		::= if_else:x i_stmt:l Com_If_e
				{:/*
				//x.set_list_command_else(l);
				//parser.list_script.clear();
				//x.close_command(new myVar());
				Utility.mf("IF ELSE: CHIUSO");
				parser.list_script = x.getBackupCommand();
				x.print_parameters();
				RESULT = x;
				*/:}
		| if_head_half:x Com_If_e
				{:/*
				//x.close_command();
				Utility.mf("IF: CHIUSO");
				//Utility.mf("LISTA IF?: "+((parser.list_script==null)?"si":"no"));
				parser.list_script = x.getBackupCommand();
				//Utility.mf("LISTA GENERALE?: "+((parser.list_script==null)?"si":"no"));
				//x.print_parameters();
				RESULT = x;
				*/:}
;

// **************** FOREACH statement

for_arg		::= Var:x	{:/* RESULT = parser.vm.extractVar(x); 
					System.out.println("Var: "+x); */:}
		| Int:x		{:/* RESULT = new myVar(myVar._int, x.intValue()); 	*/:}
		| Vint:x	{:/* RESULT= new myVar(myVar._float, x.floatValue()); 	*/:}
		| ID:x		{:/* RESULT= new myVar(myVar._string, x); */:}
;

for_head	::= Com_For for_arg:x for_arg:y for_arg:z Com_For_m EL
				{:/*
				System.out.println("FOR HEAD variabili "+x.getValue()+"\t"+y.getValue()+"\t"+z.getValue());
				for_command fc = new for_command(x,y,z,parser.vm);
				Utility.mf("\tSUBLEVEL: "+(++parser.sublevel));
				RESULT = fc;
				*/:}
;

i_Op_ps		::= Plus:x	{:/* RESULT = x; 						*/:}
		| Minus:x	{:/* RESULT = x; 						*/:}
;


//check if minus is passed for value step
for_tail 	::= Com_For_e i_Op_ps:s for_arg:y 
				{:/* 
				Utility.mf("CICLO FOR CHIUSO");
				Utility.mf("\tSUBLEVEL: "+(--parser.sublevel));
				Utility.mf("step: "+parser.vm.Auto_Neg(y,s));
				RESULT = parser.vm.Auto_Neg(y,s);
				*/:}
;

for_stmt	::= for_head:x i_stmt:l for_tail:y
		{:/*
		x.set_list_command(l);
		parser.list_script.clear();
		x.close_command(y);
		System.out.println("for cycle");
		RESULT = x;
		*/:}
;


